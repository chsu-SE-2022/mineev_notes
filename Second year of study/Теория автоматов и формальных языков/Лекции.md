

# Лекция 3



# Лекция 4
## Конечные автоматы

$A=(X,F,S,S_{0},\delta)$
$X={...}$ $F\subseteq S$
$S={...}$
$\delta:X x S\to S$
$(\delta;X)\to S_{j}$

Функция $\delta$ может быть частичной()

Конечные автоматы могут быть:
- детерминированные(ДКА) 
- недетерминированные(НКА) 

![[Конечные автоматы.png]]

$(S_{i},x)\to S_{j}$
$(S_{i},x)\to S_{k}$

Автомат **допускает слово** в заданном алфавите $X$, если начав работу с заданным словом он останавливается в одном из выделенных заключительных состояний.

Работа автомата над заданным словом - это путь из начальной вершины $S_{0}$. Последовательность вершин этого пути - это последовательность состояний принимаемых автоматом, а образ пути по дугам - это читаемое слово. Любой путь в графе автомата начинающийся в вершине $S_{0}$ и заканчивающийся в вершине $F\subseteq S$ порождает слово, допускаемое состояние.

Конечный автомат часто используется для задания множества допустимых входных последовательностей-слов. 

Конечный автомат является распознавателем если он при работе с заданным словом начав с состояния $S_{0}$ останавливается в одном из заключительных состояний этого автомата $F$. ($F\subseteq S$)

$X={a,b,c}$
$S={0,1,2,3,4,5}$
$S_{0}={0}$
$F={3,5}$

![[Пример конечного автомата (1).png]]

$A={X,S,S_{0},F,\delta}$
$X={a,b}$
$S={0,1,2,3}$
$F={1,2}$
$\delta:(S_{1};a)$
$(S_{0},b)\to S_{1}$ $(S_{2},c)\to S_{1}$
$(S_{0},c)\to S_{0}$ $(S_{2},a)\to S_{0}$
$(S_{1},a)\to S_{3}$ $(S_{2},b)\to S_{0}$
$(S_{3},b)\to S_{3}$ $(S_{3},a)\to S_{0}$
$(S_{1},b)\to S_{2}$ $(S_{3},c)\to S_{0}$
$(S_{1},c)\to S_{2}$ 

![[Пример конечного автомата (2).png]]

1) $aaba-S_{0}$
2) $abcc+S_{2}$
3) $bcccc+S_{1}$
4) $aabbcc-$

Построить конечный автомат распознающий множество целых констант: 35,-35,+35.

$A=(X,S,F,S_{0},\delta$
$x={0...9,-,+}$
$F={2}$

![[Пример конечного автомата (3).png]]

$\delta:(S_{0},+)\to S_{1}$
$(S_{0},-)\to S_{1}$
$(S_{0},ц)\to S_{2}$
$(S_{1},ц)\to S_{2}$
$(S_{2},ц)\to S_{2}$

Вещественные константы:
35.14    -356.12
+1.412    $\pm768$

1) $0\to2\to2\to4\to4\to4$
2) $0\to1\to2\to2\to2\to4\to4\to4$
3) $0\to4\to4\to4\to4$
4) $0\to1\to3\to4\to4\to4\to4$

![[Пример конечного автомата (3).png]]
![[Пример конечного автомата (4).png]]
![[Пример конечного автомата (5).png]]

# Лекция 4

### Формальные языки и грамматики

Словарь - некое конечное множество элементов-букв.
Цепочка символов - это последовательность любых допустимых символов алфавита, следуемая одна за другим (не обязана быть осмысленной).

Цепочка над алфавитом: $\alpha(V)$

Для цепочки важны количество, состав и порядок символов.

Цепочки $\alpha$ и $\beta$ равны если они имеют один и тот же состав количество и порядок следования символов.

**Операции над цепочками:**
- конкатенация (объединение или сложение) $\cup{},+$
- итерация $\cdot{}$
- пустая цепочка

Приоритет:
скобки > пустая строка > конкатенация > итерация

Языком $L$ над алфавитом $V$ называется подмножество цепочек конечной длины из множества всех цепочек $\alpha$ над алфавитом $V$.

**Операции над языками:**
1. Объединение $L\cup{M}$ - множество слов, принадлежащих хотя бы одному из языков
2. Конкатенация $L\cdot{M}$ - множество слов, полученных следующим образом: берётся слово из $L$ и справа к нему присоединяется слово из $M$
3. Итерация $L*$ - ноль или более конкатенаций $L$
4. Позитивное замыкание $L^{+}$ - одна или более конкатенаций $L$. 

Пример:
$L=\{A..Z,a..z\},D=\{0,1..9\}$
$L\cup{D}=\{A..Z,a..z,0..9\}$ - множество букв и цифр
$L\cdot{D}=\{a0,b1..\}$
$L^{*}=\{\emptyset{}abcd..z\}$ - множество всех строк из букв, включая пустую
$L^{4}=\{abcd,ftre,jklo..\}$ - множество всех строк из букв, длиной в 4 символа
$L(L\cup{D})=\{aa,a1..\}$ - множество строк, где первый символ - буква, второй - буква или цифра
$L(L\cup{D})^{*}=\{aa,a1,f1d,e2131f\}$ - множество строк, где первый символ - буква, а любое количество следующих - буква или цифра (например переменные)

**Способы задание языка:**
- перечислить все допустимые цепочки
- указания способов порождения цепочек языка (задать грамматику)
- определение методов распознавания цепочек языка (автоматы)

### Регулярные множества и выражения

Пусть K1 и K2 - множества цепочек
$K1 \cup{} K2$
$K1 \cap{} K2$
$K1*, K2*$

Класс регулярных множеств над конечным словарем $V$ определяется следующим образом:
1. $\varnothing{}\rightarrow{\{E\}}$
2. $a\in {V}\rightarrow{\{a\}}$, то этот символ есть регулярное множество
3. $S,T$ - регулярные множества, $\rightarrow{S\cup{T},S\cdot{T},S*,T*}$

Регулярные множества можно описать регулярными выражениями (формулами).

Класс регулярных выражений над конечным словарем $V$ определяется следующим образом:
1. $\emptyset{}\rightarrow{\{E\}}$ 
2. $a\in{V}\rightarrow{\{a\}}$ 
3. $S,T$ - регулярные выражение, $\rightarrow{S+{T},S\cdot{T},S*,T*}$ - регулярные выражения

Регулярные выражения - это форма или шаблон, схематично показывающая, как было построено, соответствующее ей регулярное множество с помощью операции 1-3.

Пример 1:
Задан алфавит $V=\{a,b\}$
1) $b\cdot{}a*$ - регулярное выражение
Регулярное выражение определяет множество цепочек, начинающихся с $b$ и заканчивающихся произвольным количеством $a$
$\{b,ba,baa..\}$
2) $a^{*}ba^{*}ba^{*}$
Регулярное выражение определяет множество цепочек, начинающихся с произвольного количества $a$ и содержащих ровно два вхождения $b$
3) $(a+bb)^{*}$
$\{NULL, a, bb, abb, aabb, aaabb, aaabbbb, bba\}$
Регулярное выражение определяет множество цепочек, состоящих из произвольного количества $a$ и произвольного количества пар $b$
4) $(a+b)^{*}(aa+bb)(a+b)^{*}$
$\{aa,bb,abbb, abaab\}$
Регулярное выражение, содержащее хотя бы одну пару рядомстоящих $a$ или $b$
5) $a(a+b)^{*}b$
...начинающихся на $a$, заканчивающихся на $b$ и содержащих произвольное количество $a,b$

### Формальные языки и грамматики

Язык программирование определяется синтаксисом и семантикой.

Формальное определение синтаксиса языка программирования, называется ==грамматикой==.

Теория формальных грамматик - это математический аппарат для изучения синтаксиса зыков программирования.

Язык над алфавитом $L(V)$ - это множество цепочек.

Существует два способа определения класса языков:
1. порождающая процедура - задается с помощью конечного множества правил, называемых грамматикой и порождающих в точности те цепочки которые принадлежат языку
2. распознающая процедура - задается некоторым абстрактным распознающим устройством (автоматом)

При построение трансляторов используются оба способа: грамматика, как средство описания синтаксиса языка программирования, а автомат как модель алгоритма распознавания предложений языка, которой кладется в основу построения транслятора. При это методически и технологически сначала проектируется грамматика, а затем по ней, как по источнику, строится алгоритм распознавателя.

Формальной порождающей грамматикой называется грамматика вида:
$G=(I,N,P,S)$

$T$ - конечное, не пустое множество терминальных символов. Терминалы - это терминальный словарь грамматики. Представляют собой базовые символы из которых строятся строки. Записываются строчными латинскими буквами.

$N$ - это конечное, не пустое множество нетерминальных символов (нетерминальный словарь грамматики). Записываются заглавными латинскими буквами. Нетерминалы представляют собой переменные, которые обозначают множество строк. Которые помогают в определении языка порождаемого грамматикой.

$P$ - множество продукции или правил. Продукция определяет способ, которым терминалы и нетерминалы объединяются друг с другом для создания строк.

$\alpha\to\beta$
В слове $\alpha$ присутствует нетерминальный символ.
Продукция с одинаковой объектной частью разделяется слешом (/).

$S\in N$
Стартовый символ грамматики (аксиома).
Стартовый символ - первый из нетерминальной части в списке продукции.

Пример:
$E\to T|E+T|E-T$
$T\to F|T*F|T/F$
$F\to a|b|c|(E)$

$G=(I,N,P,S)$
$T={a,b,c,+,-,*,/,(,)}$
$N={E,T,F}$
$S=E$

$E\implies T \implies T*F \implies T*F\implies F*F \implies (E)*F \implies (F+T)*F \implies (F+T)*F \implies (a+T)*F \implies (a+F)*F \implies (a+b)*F \implies (a+b)*c$

$(a+b)*c$ - может быть получена с помощью таких правил

Цепочка $w'$ непосредственно выводимая из $w$ c грамматикой $G$, если в множестве продукции есть правило вывода из $\phi \to \psi$.

$w \implies w'$
$w* \implies w'$
$w \implies$
$w \implies w_{1} \implies w_{2} \implies ... \implies w'$

Строка терминальных символов, полученная из стартового символа грамматики, называется предложением языка. Строки терминальных символов, порождаемые из стартового символа грамматики, образуют язык порождаемый этой грамматикой.

Практическое применение грамматик связанно с проблемой распознавания. Проблема распознавания разрешима, если существует алгоритм, который за конечное число шагов дает ответ на вопрос, "принадлежит ли произвольная цепочка над основным словарем грамматики языку порождаемого этой грамматикой". Если такой алгоритм существует, то язык называется распознаваемым. 
Если число шагов этого алгоритма зависит от цепочки и возможна предварительная оценка длины алгоритма, такой язык называется легко распознаваемый. На практике рассматриваются такие частные классы порождающих грамматик, которые соответствуют распознаваемым языкам. 

Наиболее важные классы таких грамматик предложены в 1959 году Наомом Хомским. 

Классификация грамматик по типу правил по Хомскому.