## Деревья

==Дерево== - это совокупность элементов называемых узлами, один из которых определяется как корень и родительских отношений, определяющих иерархическую структуру дерева.

**Рекурсивное дерево:**
1. Один узел является деревом. Этот же узел является его корнями.
2. Пусть узел $n$ узел и $T_{1},T_{2}, ... ,T_{k}$ деревья с корнями $n_{1},n_{2}, ... ,n_{k}$ соответственно. 
3. 
   Можно построить новое дерево сделав $n$ родителей узлов $T_{1},T_{2}, ... ,T_{n}$. В этом дереве $n-корень$, $T_{1},T_{2}, ... ,T_{k}$ - поддеревья узла $n$ (корня), а узлы $n_{1},n_{2}, ... ,n_{k}$ - прямые потомки (сыновья) узла $n$.

**Определения:**
1. Путем из узла $n_{1}$ в узел $n_{k}$ называется последовательность вершин $n_1,n_2,n_{k-1},n_k$ где для всех $i$ больше или равных 1 меньше $k$ узел $n_{i}$ является родительским для узла $n_{i+1}$.
2. Длиной пути называется число на единицу меньшее количества узлов составляющих этот путь.
3. Если существует путь из узла $a$ в узел $b$, то $a$ предок узла $b$, а $b$ потомок узла $a$.

Считается что любой узел является предком и потомком самому себе.
Таким образом корень дерева это узел не имеющий ни каких предков кроме самого себя.
4. Узел не имеющий потомков кроме самого себя, называется листом или терминальной вершиной дерева.
5. Высотой вершины называется длина самого длинного пути от этой вершины до одного из листов дерева (до самого длинного).
   Высотой дерева, называется высота его корня.
6. Глубина узла - это длин пути от корня до этого узла.
7. Дерево в котором нет ни одного узла называется нулевым деревом.

![[Пример дерева.png]]

Корень дерева - $A$
Листья дерева - $E,F,J,K,H,I$
Высота дерева - 3

**Способы обхода дерева:**
- Обход дерева фактически является упорядочением его вершин по некоторым правилам.

Наиболее часто встречается 3 вида обхода деревьев:
- прямой
- обратный
- симметричный

**Правила обхода:**
- Если дерево $T$ является нулевым деревом, то в список обхода заносится нулевая запись.
- Если дерево состоит из одного узла, то в список обхода заносится этот узел.
- Пусть $T$ - дерево с корнем $n$ и поддеревьями $T_{1},T_{2}, ... ,T_{k}$. 

![[Правила обхода.png]]

![[Пример дерева.png]]

$A B E F C G J K D H I$

Тогда для различных способов обхода:
1. При прямом обходе сначала посещается корень $n$, затем поддеревья  $T_{1},T_{2}, ... ,T_{k}$, также в прямом порядке.

![[Пример дерева.png]]

$A B E F C G J K D H I$

2. При обратном обходе сначала в обратном порядке обходится под дерево $T_{1}$ затем $T_{2}, ... ,T_{k}$, последним обходится $n$.

![[Пример дерева.png]]
$E F B J K G C H I D A$

3. При симметричном обходе сначала в симметричном порядке обходится поддерево $T_{1}$, затем корень $n$, далее поддеревья $T_{2}, ... ,T_{k}$

![[Пример дерева.png]]
$E B F A C J G K H D I$

### Бинарные деревья

Отдельный интерес в теории алгоритмов вызывают деревья у каждого узла которых не более двух потомков. Такие деревья называются бинарными или двоичными.

Бинарное дерево называется сбалансированным если разность высот левого и правого поддеревьев у любого узла дерева равна $|\pm x|$.

Если эта разность для любого узла равна 0, то дерево идеально сбалансировано.

### Способы представления бинарных деревьев:

1. С помощью одномерного массива

![[Способы представления бинарных деревьев (с помощью одномерного массива).png]]

$A B C D E F$

![[Способы представления бинарных деревьев.png]]

2. Представление с помощью динамической структуры

```cpp
struct Node{
	int data;
	Node *left,*right;
};

void add(int x,Node *&node){
	if (node==NULL){
		node=new Node;
		node->data=x;
		node->left=NULL;
		node->right=NULL;
	}
}

//Прямой обход (если вывод в конце - обратный, в середине - семмитричный)
void printTree(Node *node){
	if (node != NULL){
	cout << node->data << " ";
	ptintTree(node->left);
	printTree(node->right);
	}
}

int main(){
	Node *root=NULL;
	add(33,root);
	add(2,root->left);
	add(46,root->right);
	add(13,root->left->left);
	add(27,root->left->right);
	add(666,root->left->left->right);
	ptintTree(root);
	cout << endl; 
	system("pause");
	return 0;
}
```

![[Способы представления бинарных деревьев (с помощью динамической структуры).png]]

### Дерево Хаффмана

Будем строить бинарное дерево Хаффмана с использованием динамических структур данных. Узел будет содержать частоту (вероятность) вхождения символа, сам символ, а также указатели на левое поддерево, на правое поддерево и родительский узел.

По мимо структуры объявим два одномерных массива размером 256 элементов. В массиве `trees` будем хранить указатели на узлы с отдельными символами. По мере построения дерева будем объединять эти символы в деревья. Указатели на корни также хранить в этом массиве и так до тех пор пока не останется одного дерева. В массиве `symbols` - указатели на каждый символ, чтобы используя их, двигаясь к родительским узлам, быстро найти код символа. В переменной `size` - реальное число символов


```cpp
class HaffmanTree{
private:
struct Node{
	double p;
	char c;
	Node *left,*right,*parent;
};

Node *trees[256], symbols[256];
int size;

public:
	HuffmanTree(int col){size=col;}
	
	void makeTree(int col){
		if (col>1){
			double minp1=1;
			int n1=0;
			for (int i=0;i<size;i++)//ищем первый минимум
				if (trees[i] != NULL && trees[i]->p<minp1){
				}
		double minip2=1;
		int n2=0;
		for (int i=0;i<size;i++)//ищем второй минимум
			if (trees[i] != NULL && trees[i]->p<minp2 && i != n1){
				minp2=trees[i]->p;
				n2=i;
			}
		Node *tmp = new Node;//новое дерево
		tmp->left=trees[n1];tmp->right=trees[n2];
		trees[n1]->parent=tmp;trees[n2]->parent=tmp;
		tmp->p=trees[n1]->p+trees[n2]->p;
		tmp->parent=NULL;
		tress[n1]=tmp;
		trees[n2]=NULL;
		makeTree(col-1);//опять в лес по дрова...
	}
}
		void readInfo(){
			for (int i=0;i<size;i++){
				trees[i]=new Node;
				symbols[i]=trees[i];
				cout << "Eter symbol: ";cin >> trees[i]->c;
				cout << "p=";cin >> trees[i]->p;
				trees[i]->left=NULL;
				trees[i]->right=NULL;
				trees[i]->parent=NULL;
			}
		}
	void showCodes(){
		if (size==1) 
			cout << symbols[0]->c << " - " << endl;
		else {
			Node *tmp;
			string code;
			for (int i=0;i<size;i++){
				tmp=symbols[i];
				code="";
				while (tmp->parent != NULL){
					if (tmp->parent->left==tmp)
						code="0"+code;
					else
						code="1"+code;
					tmp=tmp->parent;}
					
			cout << symbols[i]->c << " - " << endl;
			}
			}
		
		}	
	};

int main(){
	int col=5;
	HaffmanTree ht(col);
	ht.readInfo();
	ht.makeTree(col);
	ht.showCodes();
	cout << endl;
	system("pause")
	return 0;
}
```


## Алгоритмы полного перебора

Многие задачи заключаются в нахождении одного или нескольких искомых из полного набора некоторых вариантов. Эти задачи называются задачами выбора на доборе дискретных данных. Самый простой способ решения задачи выбора - перебрать все варианты и выбрать среди них те которые требуются по условию.

Плюсом данного метода является гарантированное получение точного и полного результата. Главным минусом является большая временная сложность алгоритма при большом наборе исходном данных. 

### Перебор циклами

Программа представляет собой несколько вложенных циклов которые и перебирают все варианты. 

Пример: Найти количество счастливых автобусных билетов.


```cpp
int col=0;
for (int a=0;a<=9;a++)
	for (int b=;b<=9;b++)
		for (int c=0;c<=9;c++)
			for (int d=0;d<=9;d++)
				for (int e=0;e<=9;e++)
					for (int f=0;f<=9;f++)
		if (a+b+c==d+e+f) col++;
		cout << col << " " << col/10000.0 << endl;


```

Преимущество перебора циклами:
- простота реализации
Недостатки:
- часто заранее неизвестно какое количество циклов нужно вкладывать друг в друга

### P-ичный перебор

Имеется $N$ объектов каждому их которых поставлена некоторая стоимость. Требуется разделить объекты на две группы так, чтобы разность стоимостей между группами была минимальной.

Поскольку каждый объект может оказаться в одной из двух групп закрепим за каждым из объектов двоичное число (0 или 1). Если количество объектов $N$ для полного перебора необходимо просмотреть все комбинации $n$-значных двоичных чисел от $n$-нулей и $n$-единиц. Всего $2^i$.

Для реализации помимо массива объектов можно завести массив нулей и единиц. Считая его двоичным числом, на каждом шаге при выборе нового варианта прибавляя к этому числу 1.

```cpp
void plus(int *m,int n){
	int i=n;
	while (m[i]==1)
		mm[i--]=0;
	m[i]=1;
	}

int main(){
	const int n=5;
	int min=15;
	int m[n+1]={0,1,2,3,4,5},
		bin[n+1]={0,0,0,0,0,0};
	while (bin[0]==0){
		int s1=0,s2=0;
		for (int i=1;i,+n;i++)
			if (bin[i]==0) {s1+=m[i];}
			else {s2+=m[i];}
			if (abs(s1-s2)<min)
				min=abs(s1-s2);
			plus(bin,n)
	}
}
```

Данная задача решена методом полного двоичного перебора. В общем случаи перебор может быть P-ичным.
Например: Цифры 1,2,3,4,5,6,7,8,9 записаны одна за другой. Расставить между ними знаки $+, -, *, :$ или ничего , так чтобы получилось заданное число $N$. Задачу можно решит полным пятеричным перебором.

### Полный рекурсивный перебор

Дан квадратный числовой массив. Найти путь из левого верхнего угла массива в правый нижний, чтобы сумма чисел по данному пути была максимальной. Из каждого элемента массива допустимо двигается только вправо или вниз.

![[Полный рекурсивный перебор (Пример).png]]


```cpp
int Max=0;
void poisk(int *m,int n,int i,int j,int s){
	s+=m[i][j];
	if (i==n-1 && j==n-1 && s>Max) Max=s;
	if (i<n-1) poisk(m,n,i+1,j,s);
		if (j<n-1) poisk(m,n,i,j+1,s);
}

int main(){
	const int n=5;
	int m[n][n]={{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1}};
	int **a=new int*[n];
	for (int i=0;i<n;i++){
		a[i]=new int [n];
		for (int j=0;j<n,j++)
			a[i][j]=1;
		}
		poisk(a,n,0,0,0);
}
```

Основной плюс функций рекурсивного перебора в их простоте и компактности. Минус возможное переполнение стека и медленная работа.