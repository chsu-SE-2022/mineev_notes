## Метод динамического программирования

В предыдущей задаче на больших $N$ полный перебор невозможен. 

Данную задачу модно решить более быстрым алгоритмом, реализующим метод динамического программирования. Суть метода заключается в том, что в начале решается задача минимальной размерности. Далее на основании этого решения задача следующей размерности, и так далее пока не будет решена задача требуемой размерности. При решении задачи размерности $k$ на основании уже решеной $k-1$ размерности решение принимается на основании так называемого принципа оптимальности.

**Пример 1:**
Предыдущую задачу можно решить методом динамического программирования (как это делалось на ЕГЭ).

$A:$

|  5  |  7  |  1  |  8  |  2  |
|:---:|:---:|:---:|:---:|:---:|
|  3  |  9  |  2  |  5  |  6  |
|  7  |  6  |  1  |  2  |  7  |
|  5  |  4  |  3  |  2  |  8  |
|  9  |  9  |  6  |  1  |  2  |

$B:$

|  5  | 12  | 13  | 21  | 23  |
|:---:|:---:|:---:|:---:|:---:|
|  8  | 21  | 23  | 28  | 34  |
| 15  | 27  | 28  | 30  | 41  |
| 20  | 31  | 34  | 36  | 49  |
| 29  | 40  | 46  | 47  | 51  | 

Заполняя на основании исходного массива $A$ итоговый массив $B$, мы в ячейке `B[n-1][n-1]` получим исходное максимальное значение.

Для все элементов массива $B$, кроме тех которые стоят в первом столбце и первой строке, значение вычисляется по формуле: 
`B[i][j] = Max(A[i][j]+B[i-1][j];A[i][j]+B[i][i-1]`
Это и есть принцип оптимальности. (для данной задачи)

Если требуется найти не только максимальное значение суммы, но и путь по которому эта сумма была получена, это можно сделать двигаясь от элемента массива с индексами `B[n-1][n-1]` к элементу `B[0][0]` по "жадному" алгоритму.

|  1  |  1  |  1  |  1  |  1  |
|:---:|:---:|:---:|:---:|:---:|
|  1  |  2  |  3  |  4  |  5  |
|  1  |  3  |  6  | 10  | 15  |
|  1  |  4  | 10  | 20  | 35  |
|  1  |  5  | 15  | 35  | 70  |

Получается треугольник Паскаля.

**Пример 2:**
Кое кто хочет подписать бумагу у министра, министр подписывает документ, если на нем стоит подпись любого работника с последнего этажа министерства. Каждый работник сидит в отдельном кабинете. Количество кабинетов $1\le M \le 500$, этажей $1 \le N \le100$ 
Каждый работник сидит в отдельном кабинете, подписывает документ, если на нем стоит подпись любого работника из кабинета ниже или из одного из соседних. За свою подпись каждый работник берет некоторую сумму. Известность этой суммы в каждом кабинете министерства. Требуется найти путь от первого этажа министерства к последнему, чтобы конечная сумма была минимальной.

Заведем 3 двумерных массива. В первом хранятся исходные данные суммы в каждом кабинете, во втором будем просчитывать наилучшую сумму для каждого кабинета, в третьем будем отмечать путь (откуда пришли).

![[Метод динамического программирования. Пример 2.png]]

После заполнения массивов $B$ и $C$ в последней заполненной строке находим минимум, это и будет итоговое значение суммы.
Путь по министерству найдем, пользуясь массивом $C$. 

`input.txt`
5 7 
10 10 10 10 10 1 10
10 10 10 10 1 1 10
10 10 1 1 1 10 10
10 10 1 10 10 10 10
10 10 1 10 10 10 10


```cpp
void main() {
	int m,n;
	ifstream f("input.txt");
	f >> n >> m;
	int *currentFloor = new int[m];
	int *bestFloor = new int[m];
	int **direction = new int *[n];
	for (int i=0;i<n;i++) {
		direction[i] = new int[m];
		for (int j=0;j<m;j++) {
			direction[i][j]=0;
			bestFloor[j]=0;
		}
	}
	for (int i=0;i<n;i++) {
		fot (int j=0;j<n;j++) {
			f >> currentFloor[j];
			bestFloor[j]+=currentFloor[j] // идем снизу
		}
		for (int j=1;j<m;j++) {
			if (bestFloor[j-1]+currentFloor[j]<bestFloor[j]) {
				 bestFloor[j]=bestFloor[j-1]+currentFloor[j];
				 direction[i][j]=-1;
			}
		}
		for (int j=m-2;j>=0;j--) {
			if (bestFloor[j+1]+currentFloor[j]<bestFloor[j]) {
				 bestFloor[j]=bestFloor[j+1]+currentFloor[j];
				 direction[i][j]=1;
			}
		}
	}
	int min=100000000, nmin=-1;
	for (int j=0;j<m;j++) {
		if (min>bestFloor[j]){min=bestFloor[j]; nmin=j;}
	}
	
	cout << nmin << " - " << min << endl;
	
	for (int i=0;i<n;i++) {
		for (int j=0;j<m;j++) {
			cout << direction[i][j];
		}
	cout <<endl;
	}
	
	f.close();
		
		
}

```


Задача о рюкзаке
Имеется $N$ видов предмета, масса одного предмета $i-го$ вида $m_{i}$, стоимость одного предмета $i-го$ вида $s_{i}$, количество предметов каждого вида неограниченно. Имеется рюкзак, который может выдержать массу $Mr$. Сколько предметов каждого вида нужно поместить в рюкзак, чтобы рюкзак не порвался и стоимость предметов в рюкзаке была максимальна. Для решения будем просчитывать все рюкзаки с $Mr$ равного 0 и заканчивая последним значением. Сначала каждый из рюкзаков будем помещать предметы первого вида просчитывая стоимость рюкзака. Затем также в каждый из них будем пытаться поместить 0,1,2, ... предметов второго вида, заполняя остаток предметами первого, а этот остаток уже посчитан.

1. type - m=2;s=5
2. type - m=1;s=7
3. type - m=3;s=10

| Mr  |   1 type    |      2 type      | 3 type |
|:---:|:-----------:|:----------------:|:------:|
|  0  | 1 - 0; s=0  | 1 -0,2 - 0,s = 0 |        |
|  1  | 1 - 0; s=0  | 1 -0,2 - 1,s = 2 |        |
|  2  | 1 - 1; s=5  | 1 -0,2 - 1,s = 5 |        |
|  3  | 1 - 1; s=5  | 1 -1,2 - 0,s = 7 |        |
|  4  | 1 - 2; s=10 | 1 -1,2 - 1,s = 0 |        |
|  5  | 1 - 2; s=10 | 1 -1,2 - 2,s = 0 |        |