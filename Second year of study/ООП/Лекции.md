
### Что такое ООП?

==Объектно-ориентированная программа== - совокупность объектов, взаимодействующих друг с другом посредством передачи сообщений. В результате этих взаимодействий реализуется требуемый функционал.

==Объектно-ориентированное программирование== - программирование, сфокусированное на данных, данные и их поведение неразрывно связаны. Вместе данные виды поведения представляют собой классы, а экземплярами классов являются объект.

### Концепции ООП

Основные концепции с ООП:
1. Моделирование решаемой задачи 
2. Возможность создавать абстрактные типы данных, содержащие модели данных объекта и его поведения 
3. Инкапсуляция - разделение прав доступа к данным, а также объединение связанных данных 
4. Повышение возможности повторного использования кода путём наследования и шаблонов 
5. Полиморфная обработка родственных объектов (наследование с замещением)

### Виды данных

Все данные делятся на:
* скалярные (числовые, символьные, перечисляемые, указатели)
* агрегатные (векторные, списочные)
* векторные (массивы, структуры, классы)
* `void` для процедур (и `void*` для переопределяемых указателей)
* функции (считаются типом данных)

```cpp
// Позволяет замену определения типа данных
typedef int I;
typedef float F; 
// Определяет тип menu, который при объявлении принимает void и возвращает void
typedef void(menu)(); menu m_f[10]; 
// Определяет тип thing, который при объявлении принимает float и возвращает float 
typedef float(thing)(float);

Имя массива указывает на адрес в памяти, где находится первый элемент массива. Имя функции - указатель на адрес в памяти, где содержится сама функция.
```

![[Pasted image 20230918190256.png]]

Объекты(динамические):
1. `user_(1)`
2. `pen_(1)`
3. `point_(1)`

### Объектно-ориентированное моделирование

Пример
ТЗ:
1. Постановка
2. Обработка
3. Вывод

Требуемые понятия:
Исполнитель, инструмент, точка, фигура.

Модель:
![[Pasted image 20231003145429.png]]

<> - начало связи с агрегацией (закрашенный - композиция)
-> - направление связи, название класса, поля класса
Материализация связи - наличие связующей компонентной
функции.
[Смотреть](https://github.com/saif86/Object-Oriented-Modeling---Graphic-Editor)

Статическая модель содержит только классы, динамическая -
объекты.
```cpp
class user;
class pen;
class pixel;
class shape;
```

```cpp
{
public:
	void input(int a,int b,char *c);
	void print() const;
};
```

Определение класса:

```cpp
class имя
{
- int x; a.x != 1;
- float y; a.y != 3,3;
- void f(); ~~a.f;~~
};

имя a;
```

```cpp
struct имя
{
+ int x; b.x != 1;
+ float y; b.y != 3,3;
+ void f(); b.f;
};

имя b;
```

![[Pasted image 20230918191707.png]]

```cpp
class pixel
{
int x,y;
char *color;
}
```

**Компонентные функции:**
- конструкторы
- деструкторы
- селекторы
- модуляторы

Для правильной работы с объектами нужны специальные компонентные функции отвечающие за удаление и создание объектов (деструкторы и конструкторы).

Конструкторы:
1. Создание объекта - выделить память для объекта и записать начальное значение 
2. Имя конструктора совпадает с именем класса
3. Конструктор не имеет возвращаемого типа, а это значит в теле конструктора не используется оператор `return`
4. Конструкторов может быть много и они могут быть перегружены
5. Конструкторы могут иметь параметры, а могут и не иметь их
6. Конструкторы не наследуются
7. Конструкторы не могут быть виртуальными
8. Бывают трех типов: конструкторы для инициализации, копирующие, по умолчанию
9. Когда вызывается: автоматически (когда объявляется объект, когда в функцию передаются параметры по значению, когда функция возвращает объект класса) 
10. Конструктор можно вызвать принудительно
11. Конструкторы могут использоваться как преобразователи типов данных

Деструкторы:
1. Удаление объекта - удаление из памяти, ее освобождение
2. Имя совпадает с именем класса (но используется знак `~`)
3. Не используется `return` (нету возвратного типа)
4. Деструктор в памяти всегда один
5. Параметров не имеют
6. Не наследуются
7. Могут быть виртуальными
8. Как правило вызываются автоматически (когда объект выходит за пределы области видимости, когда при уничтожении сложного объекта сначала уничтожаются простые объекты из которых состоит более сложный объект)
9. Можно вызывать принудительно 

```cpp
class pixel{
public:
pixel(); //(по умолчанию)
pixel(int a,int b,char *c);
pixel(const pixel &m);//(копируемый конструктор)
pixel(int a); pixel(char *c);

private://(закрытый класс)
int x,y;
char *color;
};

~pixel() {delete[] color;}//деструктор (в public)

void inprint (int a,int b,char *c);
void print() const;

pixel::pixel()
{x=0;y=0;color="red";}

pixel::pixel(int a,int b,char *c){
x=a,y=b;
color=new char[struct(c)+1];
strcpy(color,c);
}

pixel t1,t2(3,4,"green");
```

![[Pasted image 20230918193915.png]]


```cpp
pixel::pixel(int a);
{x=a;y=3;color="green";}

pixel::pixel(char *c);
{x=y=10;color=new char[strlen(c)+1];
strcpy(color,c);}

```


```cpp
pixel::pixel(const pixel & m)
{x=m.x;y=m.y;
color=new char[strlen(m.color)+1];
strcpy(color,m.color);
}
```

Копирующий конструктор должен быть всегда в классе если хотя бы один указатель присутствует.

Конструктор по умолчанию имеет специальное назначение для создание массивов-объектов.

Конструктор с одним параметром является функцией преобразования одного типа данных в другой тип данных.

Инициализаторы конструкторов обязательное необходимое.

```cpp
pixel::pixel(int a,int,b,char *c): x(a),y(b)
{color=new char[strlen(c)+1];
strcpy(color,c);
}
```

Механизм передачи параметров в компонентную функцию

```cpp
void fi(type x);
void f2(type *x);
void f3(type &x);
```


### Области видимости класса

1. область видимости файла (объявление переменных)
   
```cpp
int n;
int m = 10;
```

2. область видимости пространства имен (namespace)
   
```cpp
namespace Project {
	int x;
}
```

3. область видимости блоков (локальные переменные)
   
```cpp
void func(){
	int x;

	{
		// only exists in codeblock
		int x;
	}
}
```

4. область видимости функций
   
```cpp
void f1() {
	int x;
}
```


5. область видимости класса (class)
   
```cpp
class type {
	void func();
}
void type::func();
```


[Область видимости класса](https://en.cppreference.com/w/cpp/language/scope)

Нельзя определять функцию внутри другой функции.

Исключения: определения компонентных функций возможны внутри внешних функций, если внешние функции имеют свои классы `::` - scope resolution operator, имеет самый высокий приоритет среди операторов `::` имеет бинарную и унарную формы.

```cpp
::i // unary
class::i // binary
```

### Изменчивость  

```cpp
pixel t1,t2(2,2,"red",3,4);
const pixel t3(3,3,"цвет",4,5);

class pixel
{
	mutable int x,y;
}; 

```

`mutable` - позволяет изменять const.

Полиморфизм - это способность одного и того же оператора (функции, действия, и тд.) приобретать различные значения(смыслы) в зависимости от обрабатываемых данных.

### Перегрузки:

1. перегрузки преобразования типов данных (необходима для работы смешанных выражений, для разных типов данных)
   
```cpp
char c;
int i;
float d;
pixel t;

```


```cpp
i=c+i+d;

1)c+i (с преобразованием 'c' с типом int)
2)(c+i)+d (с преобразованием 'd' с типом float)

d=c+i+d;

1)i+d (с преобразованием 'd' с типом float)
2)c+(i+d) (с преобразованием 'c' с типом int)
```

Для преобразования типов классов к более узкому типу данных используются специальные компонентные функции. Имя у всех этих функций начинается 

2. перегрузка функций
   
```cpp
f();
f(int);// 3
f(int,float);// 3, 5.1
f(char,int,float)// 'a', 3, 5.2

```

```cpp
void f();
void f(int,float);
void f(char,int,float);

```


Перегруженными могут быть как внешние, так и компонентные функции.

Алгоритм выбора перегруженной функции:
	1. найти среди перегруженных функций такую, у которой количество параметров совпадают
	2. проверяется строгое соответствие типов данных
	3. если типы не совпадают, то применятся стандартное повышение типов
	4. стандартное преобразование типов (речь об указателях) (`void*->mun*`)
	5. проверка, есть ли преобразование нестандартного типа (преобразование типа данных пользователя) (`int->pixel`)
	6. есть ли функция `void f(...);` (элипсис) (функция с перегруженным числом параметров)

3. перегрузка операторов

```cpp
c=a+b
t3=t2+t1;
t3.copy(t2.summa(t1));
```

Назначение - избавится от части компонентной функции и использовать встроенные операторы.

Перегружать можно и бинарные и унарные операторы. Эти операторы можно перегружать внешними и компонентными функциями.

Параметрами этих функций должны быть сами объявители или ссылки на них, но не указатели. Перегружать можно битовые операторы, придельные операторы, мгновенные операторы т.п. 

Часть операторов можно перегружать только компонентными функциями:

= ( )  | new
[ ] $\to$ | delete

= - оператор присвоения
[ ] - оператор обращения к элементу массива
( ) - оператор вызова функций
$\to$ - оператор обращения к элементу класса через объект

: :          ?:
size of   :*

: : - разрешенная область видимости
size of - выделить объем оперативной памяти
?: - оператор элвиса
:* - оператор обращения к элементу класса через указатель на этот указатель
. - оператор обращения к классу

```cpp
class type {
public:
	type operator - ();
	type operator + ();
	type operator ! ();// объявление компонентных функций

	type operator - (int);
	type operator + (type);
	bool operator > (float);
	bool operator < (type &);
	bool operator != (type*);// и так далее
};

type operator - (int);// объявление внешних функций
type operator + (type,type);
type operator - (type);
```

У унитарных функций 1 оператор. У бинарных функций 2 оператора.

```cpp
type t1,t2,t3;
t1.operator - ();
-t1 t1-x,t1-5;
+t1
!t1
t1.operator - (x);
t1+t2 t1.operator + (t2);// при перегрузке бинарного оператора, у левого операнда должен соответствовать классу (t1=type,t2 != type)
(this = &t1)
```

## Дружественные функции

```cpp
friend// внешняя компонентная функция
class pixel
{public:
	 pixel &operator = (const pixel &m);
}
```

Если есть компонентная функция $\to$ иметь компонентную функцию оператора присваивания (**правило**)

```cpp
pixel operator + (pixel b);
friend pixel operator + (pixel a,pixel b);
pixel &operator ++ ();
pixel &operator ++ (int);
```

friend: (**причины**)
1. перегрузка бинарных операторов
2. необходимость 
## Параметрический полиморфизм

Шаблоны функции и шаблоны классов

```cpp
template<class T> // параметрический шаблон
class pixel
{piblic:
	T get_x()const;
	static T d;
```

```cpp
template<class T>
T pixel<T>::get_x()const;
{return x;}
T pixel <T>::d=0;
```

```cpp
pixel<int>t1,t2(2,2,'red',2),t3(t2),p*;
```

Инстанцирование шаблонного класса типом int.

```cpp
pixel<int>t1,t2(2,2,'red',2),t3(t2),p*;
pixel<float>k1,k2(32,4.0,'цвет',5.0),k3(k2),*pp;

pixel<double> ...
pixel<char> ...
```

Назначение шаблона - повышение степени повторного использования кода.

```cpp
template <class t1,class t2>
template <class t>

void copy (ta[],tb[], int k) {
	for (int i=0; i<k; i++) {
		a[i]=b[i]; /*перегрузка*/
	}
}
```

```cpp
int i1[50], i2[50];
float d1[10], d2[20];
char c1[100], c2[100];
char *p1, *p2;

copy (i1,i2,50);
copy (d1,d2,20); /*не работает*/

copy (c1,c2,5);/*не одинаковые типы*/
copy (i1,d2,10);
copy (p1,i1,30);
copy (p1,p2,100);
```

В классе могут быть дружественные функции и если такая функция нешаблонная, то компилятор использует ее один раз для всех остальных данных. 

Если есть статичный данных, то при инструкциях всегда тиражируются.

Параметры шаблона $\neq$ необъявленный тип данных.