
### Что такое ООП?

==Объектно-ориентированная программа== - совокупность объектов, взаимодействующих друг с другом посредством передачи сообщений. В результате этих взаимодействий реализуется требуемый функционал.

==Объектно-ориентированное программирование== - программирование, сфокусированное на данных, данные и их поведение неразрывно связаны. Вместе данные виды поведения представляют собой классы, а экземплярами классов являются объект.

### Концепции ООП

Основные концепции с ООП:
1. Моделирование решаемой задачи 
2. Возможность создавать абстрактные типы данных, содержащие модели данных объекта и его поведения 
3. Инкапсуляция - разделение прав доступа к данным, а также объединение связанных данных 
4. Повышение возможности повторного использования кода путём наследования и шаблонов 
5. Полиморфная обработка родственных объектов (наследование с замещением)

### Виды данных

Все данные делятся на:
* скалярные (числовые, символьные, перечисляемые, указатели)
* агрегатные (векторные, списочные)
* векторные (массивы, структуры, классы)
* `void` для процедур (и `void*` для переопределяемых указателей)
* функции (считаются типом данных)

```cpp
// Позволяет замену определения типа данных
typedef int I;
typedef float F; 
// Определяет тип menu, который при объявлении принимает void и возвращает void
typedef void(menu)(); menu m_f[10]; 
// Определяет тип thing, который при объявлении принимает float и возвращает float 
typedef float(thing)(float);

Имя массива указывает на адрес в памяти, где находится первый элемент массива. Имя функции - указатель на адрес в памяти, где содержится сама функция.
```

![[Pasted image 20230918190256.png]]

Объекты(динамические):
1. `user_(1)`
2. `pen_(1)`
3. `point_(1)`

### Объектно-ориентированное моделирование

Пример
ТЗ:
1. Постановка
2. Обработка
3. Вывод

Требуемые понятия:
Исполнитель, инструмент, точка, фигура.

Модель:
![[Pasted image 20231003145429.png]]

<> - начало связи с агрегацией (закрашенный - композиция)
-> - направление связи, название класса, поля класса
Материализация связи - наличие связующей компонентной
функции.
[Смотреть](https://github.com/saif86/Object-Oriented-Modeling---Graphic-Editor)

Статическая модель содержит только классы, динамическая -
объекты.
```cpp
class user;
clas pen;
class pixel;
class shape;
```

```cpp
{
public:
	void input(int a,int b,char *c);
	void print() const;
};
```

Определение класса:

```cpp
class имя
{
- int x; a.x != 1;
- float y; a.y != 3,3;
- void f(); ~~a.f;~~
};

имя a;
```

```cpp
struct имя
{
+ int x; b.x != 1;
+ float y; b.y != 3,3;
+ void f(); b.f;
};

имя b;
```

![[Pasted image 20230918191707.png]]


```cpp
class pixel
{
int x,y;
char *color;
}
```

**Компонентные функции:**
- конструкторы
- деструкторы
- селекторы
- модуляторы

Для правильной работы с объектами нужны специальные компонентные функции отвечающие за удаление и создание объектов (деструкторы и конструкторы).

Конструкторы:
1. Создание объекта - выделить память для объекта и записать начальное значение 
2. Имя конструктора совпадает с именем класса
3. Конструктор не имеет возвращаемого типа, а это значит в теле конструктора не используется оператор `return`
4. Конструкторов может быть много и они могут быть перегружены
5. Конструкторы могут иметь параметры, а могут и не иметь их
6. Конструкторы не наследуются
7. Конструкторы не могут быть виртуальными
8. Бывают трех типов: конструкторы для инициализации, копирующие, по умолчанию
9. Когда вызывается: автоматически (когда объявляется объект, когда в функцию передаются параметры по значению, когда функция возвращает объект класса) 
10. Конструктор можно вызвать принудительно
11. Конструкторы могут использоваться как преобразователи типов данных

Деструкторы:
1. Удаление объекта - удаление из памяти, ее освобождение
2. Имя совпадает с именем класса (но используется знак `~`)
3. Не используется `return` (нету возвратного типа)
4. Деструктор в памяти всегда один
5. Параметров не имеют
6. Не наследуются
7. Могут быть виртуальными
8. Как правило вызываются автоматически (когда объект выходит за пределы области видимости, когда при уничтожении сложного объекта сначала уничтожаются простые объекты из которых состоит более сложный объект)
9. Можно вызывать принудительно 

```cpp
class pixel{
public:
pixel(); //(по умолчанию)
pixel(int a,int b,char *c);
pixel(const pixel &m);//(копируемый конструктор)
pixel(int a); pixel(char *c);

private://(закрытый класс)
int x,y;
char *color;
};

~pixel() {delete[] color;}//деструктор (в public)

void inprint (int a,int b,char *c);
void print() const;

pixel::pixel()
{x=0;y=0;color="red";}

pixel::pixel(int a,int b,char *c){
x=a,y=b;
color=new char[struct(c)+1];
strcpy(color,c);
}

pixel t1,t2(3,4,"green");
```

![[Pasted image 20230918193915.png]]


```cpp
pixel::pixel(int a);
{x=a;y=3;color="green";}

pixel::pixel(char *c);
{x=y=10;color=new char[strlen(c)+1];
strcpy(color,c);}

```


```cpp
pixel::pixel(const pixel & m)
{x=m.x;y=m.y;
color=new char[strlen(m.color)+1];
strcpy(color,m.color);
}
```


Копирующий конструктор должен быть всегда в классе если хотя бы один указатель присутствует.

Конструктор по умолчанию имеет специальное назначение для создание массивов-объектов.

Конструктор с одним параметром является функцией преобразования одного типа данных в другой тип данных.

Инициализаторы конструкторов обязательное необходимое.

```cpp
pixel::pixel(int a,int,b,char *c): x(a),y(b)
{color=new char[strlen(c)+1];
strcpy(color,c);
}
```

Механизм передачи параметров в компонентную функцию

```cpp
void fi(type x);
void f2(type *x);
void f3(type &x);
```


### Области видимости класса
1. область видимости файла (объявление переменных)
   
```cpp
int n;
int m = 10;
```

2. область видимости пространства имен (namespace)
   
```cpp
namespace Project {
	int x;
}
```

3. область видимости блоков (локальные переменные)
   
```cpp
void func(){
	int x;

	{
		// only exists in codeblock
		int x;
	}
}
```

4. область видимости функций
   
```cpp
void f1() {
	int x;
}
```


5. область видимости класса (class)
   
```cpp
class type {
	void func();
}
void type::func();
```


[Область видимости класса](https://en.cppreference.com/w/cpp/language/scope)

Нельзя определять функцию внутри другой функции.

Исключения: определения компонентных функций возможны внутри внешних функций, если внешние функции имеют свои классы `::` - scope resolution operator, имеет самый высокий приоритет среди операторов `::` имеет бинарную и унарную формы.

```cpp
::i // unary
class::i // binary
```

### Изменчивость  

```cpp
pixel t1,t2(2,2,"red",3,4);
const pixel t3(3,3,"цвет",4,5);

class pixel
{
	mutable int x,y;
}; 

```

`mutable` - позволяет изменять const

Полиморфизм - это способность одного и того же оператора (функции, действия, и тд.) приобретать различные значения(смыслы) в зависимости от обрабатываемых данных.

**Перегрузки:**
1. перегрузки преобразования типов данных (необходима для работы смешанных выражений, для разных типов данных)
   
```cpp
char c;
int i;
float d;
pixel t;

```


```cpp
i=c+i+d;

1)c+i (с преобразованием 'c' с типом int)
2)(c+i)+d (с преобразованием 'd' с типом float)

d=c+i+d;

1)i+d (с преобразованием 'd' с типом float)
2)c+(i+d) (с преобразованием 'c' с типом int)
```

Для преобразования типов классов к более узкому типу данных используются специальные компонентные функции. Имя у всех этих функций начинается 


2. перегрузка функций
   
```cpp
f();
f(int);
f(int,float);
f(char,int,float)

```

Перегруженными могут быть как внешние, так и компонентные функции.
3. перегрузка операторов
