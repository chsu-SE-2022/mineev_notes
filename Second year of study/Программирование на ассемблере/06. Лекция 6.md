## Условные и безусловные переходы

a. безусловный переход `SHORT`
Команды перехода не меняют флаги. В ЭВМ используются несколько команд без условного перехода, но на ассемблере они обозначаются JMP.
Определитель тем или иным способом указывает адрес перехода $\to$ адрес команды которая будет выписана следующей.

b. прямой переход
В качестве оператора указывается метка той команды, на которую передается управление.

```nasm
JMP L
...
L:MOV AX, 0
```

В ЭВМ имеется 2 такие команды прямого перехода. В одной относительный адрес перехода задается в виде байта (короткий прямой переход), а в другой команде в виде слова (длинный прямой переход). 
В этих командах операнд рассматривается, как целое число со знаком $\to$ возможен переход вперед, так и назад. Встречая символьную команду ассемблер вычисляет разность между адресом метки и адресом самой команды перехода, и оценивает величину разности. Если разность укладывается в байт, то ассемблер формирует команду короткого перехода. Если разность больше $\to$ формируется команда длинного перехода. Однако сделать этот выбор ассемблер может, если метка опознан до команды перехода. Метка = ссылка назад.
При ссылке вперед ассемблер не знает адрес метки и на всякий случай формирует команду длинного перехода. Однако программист может предоставит ассемблеру, что переход будет короткий, с помощью оператора `SHORT`, который ставится в команде до перехода перед меткой.

```nasm
JMP SHORT L
```

Если переход оказывается длинным, то ассемблер выдаст ошибку.

c. косвенный переход
В этом случае команде перехода указывается не сам адрес перехода, а то место (ячейка/регистр) где находится тот адрес, т.е. содержание регистра/ячейки рассматривается как адрес некоторой команды по которому делятся переход.

## Команды сравнения и условного перехода 

`CMP op1, op2` - сравнение

Условный переход формируется:
1. сравнивается переход некоторой величины и таким образом формируются флаги
2. в зависимости от значений флагов выписывается переход.

Команда CMP аналогична команде SUB, однако результат никуда не записывается, главный эффект это установка флага.

```nasm
Jxx <метка>
```

Все команды условного перехода делятся на 3 группы:
1. команды, которые ставятся после CMP
   E – equal (равно)
   N – not (не, отрицание)
   G – greater ( больше) – для чисел со знаком
   L – less (меньше) – для числе со знаком
   A – above (больше) – для чисел без знака
   B – below (меньше) – для числе без знака
2. команды, которые реагируют на значение флага и не используют команду CMP.

| Мнемокод | Условие перехода |
|:--------:|:----------------:|
|    JZ    |       ZF=1       |
|    JS    |       SF=1       |
|    JC    |       CF=1       |
|    JO    |       OF=1       |
|    JP    |       PF=1       |
|   JNZ    |       ZF=0       |
|   JNS    |       SF=0       |
|   JNC    |       CF=0       |
|   JNO    |       OF=0       |
|   JNP    |       PF=0       | 

   В этих командах указывается первая буква правого флага, если переход должен быть выполнен при значении 1. N, если значение флага равно 0.
   
```nasm
MOV AL, A
MUL A
JC ERROR             ; A*A> 255 (CF=1) → ERROR
ADD AL, B
JC ERROR             ; A*A+B > 255 (CF=1) → ERROR
MOV C, AL
...
ERROR: ...
```

3. команда, проверяющая значение регистра счетчика CX
   
```nasm
JCXZ <метка> (if cx:=0 then goto <метка>)
```

## Команды управления циклом

1. команда `LOOP`
   
```nasm
MOV CX, N    ; CX – счетчик цикла
L: ...
...       ;тело цикла
DEC CX    ; CX:=CX-1
CMP CX, 0    ; CX=0?
JNE L    ; CX<>0 → L
```

```nasm
MOV CX, N
L: ...
...    ;тело цикла
LOOP L
```

Например: найти N! и записать результат в регистр AX, где N – байтовая переменная.

```nasm
MOV AX, 1    ;AX:=1
MOV CL, N    ;CX:=N как слово (счетчик цикла)
MOV CH, 0    ;CX:=N как слово (счетчик цикла)
JCXZ F1    ;N=0
MOV SI, 1    ;i=1
F: MUL SI    ;(DX, AX):=AX*i (DX=0)
	INC SI    ;i:=i+1
	LOOP F
F1: ...
```

2. команды `LOOPE/LOOPZ` и `LOOPNE/LOOPNZ`
   LOOPE <метка> 
   LOOPZ <метка>
   
Например: записать в регистр BL наименьшее число из отрезка [2, K], на которое не делится число  N (N и K – байтовые переменные, 2≤K<N) или записать 0, если такого числа нет.

```nasm
MOV DL, N
MOV DH, 0
MOV CL, K
MOV CH, 0
DEC CX    ; CX:=K-1  (счетчик цикла)
MOV BL, 1
DV:  INC BL    ; очередное число из [2,K]
    MOV AX, DX
    DIV BL    ; AH:= N mod BL
    CMP AH, 0    ; mod=0 ?
    LOOPE DV    ; цикл CX раз и пока mod=0
    JNE DV1    ; mod<>0 → DV1
    MOV BL, 0    ; нет искомого числа
DV1: ...
```
