# Лекция 1

Первый микропроцессор фирмы Intel в 1971 году, который работал с четырех разрядными данными. В1974 фирма создала микропроцессор 8080, работающий с восьмью разрядными данными и памятью до 64 Кб. В1976 года фирма Apple разработала первую ЭВМ. В1978, Intel разработала процессор 8086 с памятью до 1 Мб. В 1981, Intel создала свой персональный компьютер IMB PC XT. 

В 1983 года, Intel создала процессор 80286. На его основе в 1984 году был сделан IMB PC AT. В нем теоретический уже мог использоваться многозадачный режим работы, однако возможностей процессора оказалось не достаточно. 

Реально многоразрядный режим работы мог использоваться только в 32 разрядном процессоре (i386 и i486). Эти процессоры работали в двух режимах, в котором они представляли собой более быструю версию 80286, и безопасном режиме для реализации многозадачности.

В 1993 году появился Pentium.

Во всех микропроцессорах сохраняется преемственность, то есть программа написанная для младших моделей, может быть выполнена на более старших моделях. 

Это обеспечивается тем, что в системе команд лежит система команд 8086. В новые модели лишь добавляются новые команды, главным образом для обеспечения многозадачности.

Оперативная память память делится на ячейки в 8 разрядов (байт). Разряды байта нумеруются справа на лева. 



Так как последовательность 0 и 1 бывает очень длинной, то содержание ячеек принято записывать в 16 системе.

Байты нумеруются с 0. Порядковый номер байта называется его адресом. 

![[Байт.png]]

Объем оперативной памяти $2^{20}$ байта. Поэтому для ссылок на байте памяти нужны 20 разрядные адреса от 00000h - FFFFFh.

Байт это наименьшая адресуемая ячейка памяти. Есть еще более крупные ячейки слово, двойное слово и четверное слово. 

Слово это два соседних байта. Размер слова 16 разрядов, которые нумеруются справа налево от 0 до 15. Адресом слова считается адрес его первого байта.

![[Слово.png]]

Двойное слово это 32 байта. Адрес - адрес первого байта.

![[Двойное слово.png]]

Байты используются для хранения небольших целых чисел и символов. Слова используются для хранение целых чисел и адресов. Двойное слово для хранения больших чисел и строк.

Для кратковременного хранения данных используют регистры - ячейки, расположенные в центральном процессоре и доступные из машинных программ Доступ к регистрам осуществляется намного быстрее, чем к ячейкам оперативной памяти. Все регистры имеют размер в одно слово, за каждым из них закреплено имя. По назначению и способу использования регистры делятся на уровни - регистры общего назначения, сегментные регистры, указатели команд и регистр флагов.

### Регистры общего назначения

![[Регистры общего назначения.png]]

Первые 4 регистра AX, BX, CX, DX устроены таки образом что возможен независимый доступ к их старшим и младшим половинам.
Целиком регистр используется при работе с числами, а их половины - для работы с частями чисел и символами. Регистры BP, SP, SI, DI для чтения и записи целиком. 

Особенностью всех регистров общего назначения является то что их можно использовать в любых арифметических, логических и других машинных операциях.

Если в команде операнд берется из памяти то ссылаться на него можно указав некоторый адрес и некоторый регистр. В этом случаи команда будет работать с некоторым исполнительным адресом. Который вычисляется как сумма адреса, указанного в команде и текущего значения указанного регистра. Этот процесс называется модификация адреса. А используемый при этом регистр - модификатором. Ими могут быть только 4 регистра: BX, BP, SI, Di.

Модифицировать адрес можно по двум регистрам сразу, но толь так, что один из регистров - BX или BP, а другой - SI или DI.

### Сегментные регистры

- CS - сегмент команд
- DS - сегмент данных
- SS - сегмент стека
- ES - дополнительный сегмент

16 битовые, не разделяются.

В арифметических и логических операциях эти регистры не участвуют.

Эти регистры участвуют в сегментировании адресов. Если в ЭВМ используется память большого объема, тогда для ссылок на ее ячейки приходится использовать длинные адреса, а так как эти адреса указываются в командах, то и команды оказываются длинными. 

Сократить размеры команд можно используя сегментирование. 
Любой адрес $A$ можно представить как сумму $B+d$, где $B$ - начальный адрес сегмента памяти, где находится ячейка $A$, а $d$ - это смещение.

Если сегменты памяти не большие, то и смещение $d$ будет не больше, поэтому большая часть длинного адреса будет сосредоточена в $B$.
Если в команде необходимо указать адрес, тогда заносим часть $B$ этого адреса, записываем определенный регистр, и в команде вместо $A$ указываем этот регистр и смещение $d$. Благодаря модификации данных адресов, данная команда будет работать с адресом равным сумме смещения $d$ и содержимого регистра.

Размеры сегментов памяти не должны превышать 64 Кб. Поэтому смещение это 16 разрядные адреса.

В регистре CS, находится начальный адрес сегмента команд. В регистре DS, находится начальный адрес сегмента данных. SS - указывает на начало стека. Тогда при ссылках на эти сегментах в командах, соответствующие сегментные регистры не указываются, они подразумеваются по умолчанию. 

![[IP.png]]

В регистре IP всегда находится адрес команды, которая будет выполнена следующая, поэтому абсолютный адрес этой команды определяются парой регистров CS и IP. Изменения любого из этих регистров - это переход, поэтому содержимое CS и IP можно менять только командами перехода.

![[Указатель команд.png]]

Флаг - это бит принимающий значение 1, если выполнено некоторое условие, принимающий 0, если условие не выполнено.

В процессоре 8086, используются 9 флагов, собранных в 16-разряднный регистр - Flex.

Флаги делятся:
- флаги условий - автоматически меняются, при выполнении команд и фиксируют те или иные свойства результата.
	  -  CF используется для переноса арифметических операций
	- OF - используется для арифметических операций над числами со знаком. OF = 1 - переполнение мантиссы
	- ZF = 1, если результат операции равен 0
	- SF - флаг знака. SF = 1, если в операции над знаковыми числами получился отрицательный результат
	- PF - флаг чётности. PF = 1, если в восьми младших битах результата содержатся четное количество двоичных единиц (учитывается только в операциях ввода-вывода) 
	- AF - флаг дополнительного переноса. Фиксирует особенности выполнения операций над двоично-десятичными числами.
- флаги состояний - эти флаги меняет сама программа, а их состояние оказывает влияние на дальнейшую работу процессора
	- DF - флаг направления. Устанавливает направления просмотра строк в строковых командах. DF = 0, строки просматриваются вперёд, DF = 1 - в обратном направлении
	- EF - флаг прерываний. EF = 0 - процессор перестает реагировать, на поступающие к нему прерывания. EF = 1 - блокировка снимается
	- TF - флаг трассировки. TF = 1 - после выполнение каждой команды, процессор делает прерывание, что можно использовать для отладки программы

### Представление данных и команд

В процессоре 8086 делается различие между целыми числам без знака и со знаком.

Целые числа без знака:
- Байт: 0 - 255
- Слово: 0 - 65535
- Двойное слово : 0 - 4294967295

Целые числа со знака:
- Байт: -127 - +127
- Слово: -32768 - +32767
- Двойное слово: -2147483648 - +2147483647

Числа размером в слово и двойное слово, хранятся в памяти в перевёрнутом виде. Это сделано для удобство сложения и вычитания.
Однако в регистре числа размером в слово хранятся в нормальном виде.

Знаковые числа записываются в дополнительном коде.

Отрицательное число представляется беззнаковым числом $2^{k}-|x|$, если $x<0$

Символьные данные в памяти ЭВМ хранятся в двоичном виде. Для этого каждому символу ставится соответствие некоторое неотрицательное число, называемое кодом символа. Конкретное соответствие между символами и их кодами, называется системой кодировки. В ЭВМ как правило используются 8-разрядные коды символов, это позволяет закодировать 256 символов. Обычно используется система кодировки ASCII. Под каждую строку отводят нужное количество в соседних байтах, которые записывают коды символов образующих строку. Адресом строки считается адрес его первого байта. 

### Ассемблер 

Машинный язык - это комбинация, строго организованных 0 и 1, компьютер понимает только свой машинный язык. В 50 годы 20 века, программисты стали использовать символический аналог машинного языка, который назвали языком ассемблера. Этот язык точно отображает особенности машинного языка, поэтому для каждого типа компьютера он свой.

**Алфавит ассемблера:**
- все латинские буквы A-Z (прописные и строчные считаются эквивалентными)
- цифры от 0 до 9
- спец. знаки (_ ? @ $ &)
- разделители (, . [] () < > {} + / * % ! "" \ = # ^)

Идентификатор - это последовательность допустимых символов, для обозначения имен переменных и методов. Длина может составлять 256 символов. Транслятор воспринимает первые 32 символа. Идентификатор не может начинаться с цифры. Может быть только первым символ.

Ключевые слова - это служебные символы языка ассемблер, к которым относятся название регистров и операторов. Целые числа могут записываться в десятичной, двоичной, реже в восьмеричной системе счисления. 

Символы и строки заключаются в одинарные или двойные кавычки. В качестве символов можно использовать русские буквы. В строках прописные и строчные символы не эквивалентны.

Программа на языке ассемблер - это последовательность предложений, каждый из которых записывается в отельной строке. Переносить на другую строку - нельзя. 

**По смыслу все предложения делятся на 3 группы:**
- комментарии 
- команды
- директивы

#### Комментарии

Комментарием считается любая строка начинающая со знака $;$.
Либо пустая строка. так же допустим многострочный комментарий, который начинается со слова COMMENT <маркер><текст>
Где COMMENT - директива языка ассемблер. Маркер - это любой символ, кроме пробела. Концом комментария считается конец строки, которые снова в любой позиции встретился этот же маркер.

Пример: 
```nasm
COMMENT *это все
является комментарием
к примеру * и это тоже
```
Многострочный комментарий обычно используется для временного исключения фрагмента программы. 

#### Команды

Предложения-команды - это символьная форма записи машинных команд.

Синтаксис команд: `[<метка>:]<мнемокод>[<операнды>][;<комментарий>]`

Мнемокод - это служебное слово, указывающие в символьной форме операцию, которую должна выполнить команда.

#### Директивы

Директивы - это приказы ассемблеру со следующим синтаксисом:
`[<имя>]<название директивы>[<операнды>][;<комментарий>]`

Например: 
`DB 1,-2,OFFh;`
массив X, состоящий из трех элементов.

#### Директивы определения данных размеров в байт, слово и двойное слово. 

DB - директива определения данных.
Синтаксис: `[<имя>] DB<операнд> {,<операнд>}`
Встречая такую директиву, ассемблер вычисляет операнды и записывает их значения в последовательные байты памяти. Первому из этих байтов дается указанное имя, по которому на этот байт можно ссылаться из других мест программ. 

Существует два основных способа задания операнда:
- ? (знак неопределенного значения): 
	  `X DB ?` - для переменной X отводится один байт памяти, в который ничего не записывается. Выделив в байт код переменную, ассемблер запоминает его адрес. Когда в тексте программы встретится данное имя, ассемблер заменит его на адрес, который принято называть значением имени X. Размер переменной в памяти, называется типом имени переменной. Тогда значение и тип имени переменной, однозначно определяют ячейку обозначаемую этим именем. 

В ассемблере есть оператор типа: `TYPE <имя>` 
Значением этого оператора является размер ячейки выделанной под переменную в **байтах**.
`TYPE X = BYTE = 1`
- константное выражение от - 128 до 255
 ```nasm
  A DB 254    ; 0FEh
  B DB 17h    ; 17h`
  C DB "*"    ; 2Ah
```

При описании переменных-массивов, имя дается его первому элементу, остальные остаются безымянными.

`M`

| 02  | FE  | ... | 2A  |
| --- | --- | --- | --- |

`TYPE M =  1`

Имя массива присевается к первому элементу.

Для ссылок на байты массива используют ссылки вида `M+k`, где `k`  - целое число
```nasm
M + 1; address of FE
M + 3; address of '*' (2A)
```

Если несколько соседних операндов - символы, то их можно объединить в строку.
Пример:

```nasm
S DB `a`
  DB `b`
  DB `c`

или

S DB `abc`
S DB `a`,`b`,`c`
S DB `ab`,`c`    S DB `a`,`bc`
```

Если необходимо описать байтовый массив, состоящий из нескольких байтовых элементов, можно использовать конструкцию повторения - `DUP()`
Пример:

```nasm
R DB 0,0,0,0,0,0,0,0  R DB 8 DUP(0)
```
 8 - коэффициент повторение
 DUP - служебное слово
 (...) - повторяемая величина

Двумерный массив:
```nasm
G DB 10DUP (20DUP(?))
```

`DW` - директива определения данных размером в слово

Пример:
```nasm
A DW ?  TYPE A = 1
B DW 1234h  TYPE B = 2
C DW -2  TYPE C = 2
S1 DW `01`  TYPE S1 = 2
E DW 40000, 3 DUP(?)  TYPE E = 2
```

В качестве операнда директивы `DW` может быть указана адресное выражение, то есть выражение которое является адресом. 

Пример:
```nasm
C DB ? 
D DW C  
```

Ассемблер записывает в слово выделенную под переменную `D`, адрес переменной `C`, который становится начальным значением переменной `D`.

`DD` - директивы определения данных размером в двойное слово
Диапазон значений:
- целые числа: от $-2^31$ до $2^{32}-1$
- константные выражения от $-2^15$ до $2^{16}-1$

Так как все выражения вычисляются в области 16-битовых чисел и все берется по модулю 2. Тип имени переменной равен 4.

Пример:
```nasm
A DD ?
B DD 123456h
C DD 33 DUP(?) 
```

  Ассемблер заменяет имя переменной `C`e на адресную пару состоящую из сегмента и смещения имени внутри сегмента.
  
```nasm
C DB ?
D DD C
```

Директива эквивалентности: `<имя> EQU <операнд>`

Операнд может быть:
1. операнд-имя 
   Если в правой части директивы указанно имя регистра переменной или константы, тогда имя слева объявляется синонимом данного имени и все последующие вхождения в текст программы этого имени-синонима, ассемблер будет заменять на имя указанное справа. 
	```nasm
	A DW ?
	B EQU A
	C DW B; эквивалентно C DW A
	```

2. операнд - константное выражение
    N - это константана со значением 100, K - константна 
Все последующие вхождения в текст программы имени константы заменяются на значение константы.
	```nasm
	N EQU 100
	K EQU 2*N-1
	```
3. операнд - другой текст 
   `S EQU "Привет"`

Директива присваивания - определяет константу, именем указанному слева и числовым значением указанным справа. Данная константа может менять свое значение.

Пример:
```nasm
K=10
A DW K;эквивалентно A DW 10
K=K+4
B DB k;эквивалентно B DB 14
```

Пример: чему равны переменные A,B,C,D?
```nasm
K=1
N EQU K
A DW N 
K=2
B DB N
; N = 1
; A = 1
; B = 2
```

```nasm
K = 1
N EQU K+10
C DW N
K = 2
D DW N
; N = 11
; C = 11
; D = 11
```


Выражение ассемблера вычисляются не во время выполнения программ, а во время ее трансляции.

Встретив в текст программы выражение ассемблер вычисляет его и полученное значение записывает в программу, поэтому в выражениях нельзя использовать величины, которые станут известны во время выполнения программы.

Приоритет операций:
1. (),[],LENGHT,SIZE,WIDTH,MASK
2. .
3. :
4. PTR,OFFSET,SEG,TYPE,THIS
5. HIGH,LOW
6. Одноместные +,-
7. [] *, / ,MOD,SHL,SHR
8. Двуместные +,-
9. EQ,NE,LT,GT,GE
10. NOT
11. AND
12. OR,XOR
13. SHORT,TYPEPU`