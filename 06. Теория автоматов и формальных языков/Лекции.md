# Лекция 1

Теория автоматов занимается изучением абстрактных вычислительных устройств или "машин".

1930 г. Алан Тьюринг, исследовал абстрактную машину.
Цель - описать границы между тем, что может делать вычислительная машина и тем, что она не может делать.

**Машина Тьюринга:**
- бесконечная лента с ячейками
- автомат или голова для чтения и записи
- программы

**Роль в истории:**
- Это первая математическая модель универсальных вычислений 
- Всё, что можно вычислить, описывается как машина Тьюринга
- Это описание работы компьютера, которое Тьюринг дал до его появления

**Исторический факт:**
- Машина Тьюринга использовал двоичную систему во времена, когда преобладала десятичная
- Компьютер ENIAC(1943-1945) использовал 10-ю систему
- Слово "бит" - только в 1948 г.

**Факт:**
- Тьюринг описал универсальную компьютер "общего назначения" 
- Вэнивар Буш придумал аналоговый компьютер, известный как дифференциальный анализатор. Он решал дифференциальные уравнения.

**Полнота по Тьюрингу:**
Полный по Тьюрингу язык программирования или компьютер способен имитировать Машину Тьюринга.

**Теория автоматов:**
- 1940-1950 гг. изучение простейших машин - "конечных автоматов"
- Предложены в качестве модели функционирования человеческого мозга
- 1950 г. Наом Хомский занялся изучением формальных грамматик
- Грамматики тесно связанны с абстрактными автоматами и служат основой для составляющих программ обеспечения

**Конечные автоматы:**
- Являются моделью для многих компонентов аппаратного и программного обеспечения

**Примеры использования:**
- ПО для разработки и проверки цифровых схем
- ПО для сканирования больших текстовых массивов

**Конечные автоматы (примеры использования):**
- ПО для проверки различного рода систем, которые могут находится в конечном числе различных состояний 
- "Лексический анализатор" стандартного компилятора - компонент компилятора, который отвечает за разбивку исходного текста на логические единицы - лексемы (ключевые слова, идентификаторы, знаки препинания) 

**Подходы к определению и изучению автоматов:**
- Макроподход - внешнее поведение автомата (абстрактные автоматы)
- Микроподход - структура автоматов, его составные части (структурные автоматы)
- Практический аспект - внешнее поведение и реализация
 
# Лекция 2

### Автоматное преобразование информации

- Функциональные преобразователи $F(x) = x$
- Вход - выход

Не все преобразователи информации выполняют функциональное отображение информации.

Результат преобразования вход - выход часто зависит не только от того какая информация появилась на входе, но и от того что происходило раньше, то есть и от предыстории преобразования информации (ситуация в автобусе, когда человеку несколько раз наступают на ногу).

Таким образом, существуют преобразователи информации реакция которых зависит не только от входа, но и от входной истории, такие преобразователи называются ==автоматами.==

На множестве предыстории вводятся отношения эквивалентности. Две предыстории считаются эквивалентными если они одинаковым образом влияют на дальнейшее поведение автомата. Таким образом, автомату достаточно запомнить класс эквивалентности к которому принадлежит данная предыстория. Простейший случай - когда количество классов эквивалентности конечно. Соответствующая формальная модель называется ==конечным автоматным преобразователем (конечный автомат (КА)).==

==Состоянием автомата== называется класс эквивалентности его входных историй.

==Неформальное состояние автомата== - это характеристика однозначно определяющая его дальнейшее поведение и все последующие реакции на следующие события.

Так как состояние представляет собой класс эквивалентности входных историй, то оно может изменятся только при приходе очередного входного символа. При этом конечный автомат не только выдает информацию на выход, но и меняет свое состояние.

Будущие поведение автомата определяется текущим состоянием, но не тем как автомат в него пришел.

==Неформальное определение конечного автомата== - это устройства работающие в дискретные моменты времени - такты. На вход конечного автомата в каждом такте поступает один из возможных входных сигналов, а на выходе появляется выходной сигнал, являющейся функцией его текущего состояния и поступившего входного сигнала. Внутренние состояние автомата так же меняется..

**Функционирование автомата может быть представлено в форме блок-схемы** 

![[Функционирование автомата.png]]

$S$ - текущие состояние
БП - блок памяти
$x$ - входной сигнал
$y$ - выходной сигнал

Текущие состояние $S$ хранится в блоке памяти. Это состояние и входной символ $x$ определяют выходную реакцию автомата $y$ и следующие состояние автомата.

Конечный автомат может быть задан в виде ориентированного графа где вершины графа это состояния $S$, ребра графа - это входные и выходные сигналы $x$ и $y$ .

![[Конечный автомат.png]]

$S_{i}\to{S_{j}}$ и проводится тогда, когда автомат $S_{i}$ под воздействием $x$ переходит в $S_{j}$ с выходной реакцией $y$

**На практике широкое распространение получили две основные модели:**
- модель Мура
- модель Мили

### Модель автомата Мили

Моделью автомата Мили называется шестерка компонентов следующего вида:
$A = (x,y,s,S_0,\delta,\lambda)$
$x$ - конечное непустое множество входных символов
$y$ - конечное непустое множество выходных символов
$S$ - конечное непустое множество состояний
$S_{0}$ - конечное состояние
$\delta$ - функция переходов $(S x X\to S)$
$\lambda$ - функция выходов $S x X\to Y$

Закон функционирования автомата Мили выглядит следующим образом:
$S(t++)=\delta{(s(t),x(t))}$
$Y(t)=\lambda{(s(t),x(t))}$

$t$ - текущий момент времени
$t+1$ - следующий момент времени 
$S(t+1)$ - состояние автомата в следующий момент времени
$S(t),X(t),Y(t)$ - элементы описания автомата в текущий момент времени

В модели Мили выходной символ явно зависит от состояния и символа.

**Пример:**
Автомат продавец газет может получать монеты достоинством 5 и 10 рублей. Если сумма в автомате равна 15р то автомат выдает газету. Если сумма больше то автомат возвращает деньги. Построить модель автомата Мили.

$x$:
- $x_{5}$ - опущена монета достоинством 5р
- $x_{10}$ - опущена монета достоинством 10

$y$:
- $y_{3}$ - выдача газеты
- $y_{4}$ - возврат денег
- $y_{5}$ - сообщение: принято 5р
- $y_{10}$ - сообщение: принято 10р

$S$:
- $S_{0}$ - принята сумма 0р
- $S_{5}$ - принята сумма 5р
- $S_{10}$ - принята сумма 10р

$\delta:SxX\to S$
![[Пример автомата раздатчика газет (1).png]]

$\lambda: SxX\to Y$
![[Пример автомата раздатчика газет (2).png]]

$\delta;\lambda$
![[Пример автомата раздатчика газет (3).png]]

**Ориентированный граф:**
![[Ориентированный граф.png]]

1. выдача газеты $(E_1)$
$x_{5}$ $x_{5}$ $x_{5}$ $\frac v ,$ $x_{5}$ $x_{10}$ $\frac v ,$ $x_{10}$ $x_{5}$

2. возврат денег $(E_2)$
$x_{10}$ $x_{10}$ $\frac v ,$ $x_{5}$ $x_{5}$ $x_{10}$

$E = E_1+E_2$

Имея формальное описание автомат Мили, можно вычислить реакцию автомата на любую входную последовательность.

# Лекция 3

### Протокол работы автомата Мили

| $t$   | 0       | 1        | 2        | 3        | 4       | 5        | 6        | 7        | 8        | 9        | 10       | 11      |
| --- | ------- | -------- | -------- | -------- | ------- | -------- | -------- | -------- | -------- | -------- | -------- | ------- |
| $x$   | $x_{5}$ | $x_{10}$ | $x_{10}$ | $x_{5}$  | $x_{5}$ | $x_{5}$  | $x_{10}$ | $x_{10}$ | $x_{5}$  | $x_{10}$ | $x_{10}$ |         |
| $S$   | $S_{0}$ | $S_{5}$  | $S_{0}$  | $S_{10}$ | $S_{0}$ | $S_{5}$  | $S_{10}$ | $S_{0}$  | $S_{10}$ | $S_{0}$  | $S_{10}$ | $S_{0}$ |
| $y$   | $y_{5}$ | $y_{3}$  | $y_{10}$ | $y_{3}$  | $y_{5}$ | $y_{10}$ | $y_{4}$  | $y_{10}$ | $y_{3}$  | $y_{10}$ | $y_{4}$  |         |

$(x,S,y)$

**Концепция на псевдокоде**

При реализации должен быть использован оператор swith

```
case S of:

0:
if x=x5 go to S5
if x=x10 go to S10
else err

5:
if x=x5 go to ...
if x=x10 go to ...
else err

10:

```

### Модель автомата Мура

$A=(x,y,S,S_{0},\delta,\lambda)$

$S(t+1)=\delta(S(t),x(t))$
$y(t)=\lambda(S(t))$

![[Модель автомата Мура.png]]

В модели автомата Мура выходной сигнал явно зависит только от состояния, а косвенно от его входного символа.

### Преобразование автоматов

Два автомата называются эквивалентными если они реализуют одинаковые отображения входных слов в выходные, на всей области определения отображения.

Автоматы Мили и Мура могут быть 

**Преобразование автомата Мили в автомат Мура**
Замечания:
- преобразования возможны, когда в графе автомата Мили не существует вершин в которые не входили бы не одна дуга
- каждое состояние должно иметь хотя бы одну выходящую дугу

![[Преобразование автомата Мили в автомат Мура (1).png]]

![[Преобразование автомата Мили в автомат Мура (2).png]]

Число состояний в автомате Мура больше (в среднем), чем в автомате Мили.

#### Пример: Построение автомата Мура, эквивалентного автомату Мили

![[Построение автомата Мура, эквивалентного автомату Мили.png]]

| $t$ | 0       | 1       | 2       | 3       | 4       | 5       | 6       | 7       | 8       | 9       |
| --- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| $x$ | $x_{5}$ | $x_{10}$ | $x_{10}$ | $x_{5}$ | $x_{5}$ | $x_{5}$ | $x_{10}$ | $x_{10}$ | $x_{5}$ | $x_{10}$ |
| $S$ | $S_{0}$ | $S_{5}$ | $S_{0}$ | $S_{10}$ | $S_{0}$ | $S_{5}$ | $S_{10}$ | $S_{0}$ | $S_{10}$ | $S_{0}$ |
| $y$ | $y_{5}$ | $y_{3}$ | $y_{10}$ | $y_{3}$ | $y_{5}$ | $y_{10}$ | $y_{4}$ | $y_{10}$ | $y_{3}$ | $y_{10}$ |


# ДЗ Построить автомат Мили для работы электронных часов 

a - режим
b - увеличение или уменьшение $\pm 1$

1. $A=(x,y,S,S_{0},\delta,\lambda)$

![[ДЗ Построить автомат Мили для работы электронных часов.png]]

2. граф автомата Мили
3. эквивалент автомата Мура

# Лекция 4
## Конечные автоматы

$A=(X,F,S,S_{0},\delta)$
$X={...}$ $F\subseteq S$
$S={...}$
$\delta:X x S\to S$
$(\delta;X)\to S_{j}$

Функция $\delta$ может быть частичной()

Конечные автоматы могут быть:
- детерминированные(ДКА) 
- недетерминированные(НКА) 

![[Конечные автоматы.png]]

$(S_{i},x)\to S_{j}$
$(S_{i},x)\to S_{k}$

Автомат **допускает слово** в заданном алфавите $X$, если начав работу с заданным словом он останавливается в одном из выделенных заключительных состояний.

Работа автомата над заданным словом - это путь из начальной вершины $S_{0}$. Последовательность вершин этого пути - это последовательность состояний принимаемых автоматом, а образ пути по дугам - это читаемое слово. Любой путь в графе автомата начинающийся в вершине $S_{0}$ и заканчивающийся в вершине $F\subseteq S$ порождает слово, допускаемое состояние.

Конечный автомат часто используется для задания множества допустимых входных последовательностей-слов. 

Конечный автомат является распознавателем если он при работе с заданным словом начав с состояния $S_{0}$ останавливается в одном из заключительных состояний этого автомата $F$. ($F\subseteq S$)

$X={a,b,c}$
$S={0,1,2,3,4,5}$
$S_{0}={0}$
$F={3,5}$

![[Пример конечного автомата (1).png]]

$A={X,S,S_{0},F,\delta}$
$X={a,b}$
$S={0,1,2,3}$
$F={1,2}$
$\delta:(S_{1};a)$
$(S_{0},b)\to S_{1}$ $(S_{2},c)\to S_{1}$
$(S_{0},c)\to S_{0}$ $(S_{2},a)\to S_{0}$
$(S_{1},a)\to S_{3}$ $(S_{2},b)\to S_{0}$
$(S_{3},b)\to S_{3}$ $(S_{3},a)\to S_{0}$
$(S_{1},b)\to S_{2}$ $(S_{3},c)\to S_{0}$
$(S_{1},c)\to S_{2}$ 

![[Пример конечного автомата (2).png]]

1) $aaba-S_{0}$
2) $abcc+S_{2}$
3) $bcccc+S_{1}$
4) $aabbcc-$

Построить конечный автомат распознающий множество целых констант: 35,-35,+35.

$A=(X,S,F,S_{0},\delta$
$x={0...9,-,+}$
$F={2}$

![[Пример конечного автомата (3).png]]

$\delta:(S_{0},+)\to S_{1}$
$(S_{0},-)\to S_{1}$
$(S_{0},ц)\to S_{2}$
$(S_{1},ц)\to S_{2}$
$(S_{2},ц)\to S_{2}$

Вещественные константы:
35.14    -356.12
+1.412    $\pm768$

1) $0\to2\to2\to4\to4\to4$
2) $0\to1\to2\to2\to2\to4\to4\to4$
3) $0\to4\to4\to4\to4$
4) $0\to1\to3\to4\to4\to4\to4$

![[Пример конечного автомата (3).png]]
![[Пример конечного автомата (4).png]]
![[Пример конечного автомата (5).png]]

# Лекция 4

### Формальные языки и грамматики

Словарь - некое конечное множество элементов-букв.
Цепочка символов - это последовательность любых допустимых символов алфавита, следуемая одна за другим (не обязана быть осмысленной).

Цепочка над алфавитом: $\alpha(V)$

Для цепочки важны количество, состав и порядок символов.

Цепочки $\alpha$ и $\beta$ равны если они имеют один и тот же состав количество и порядок следования символов.

**Операции над цепочками:**
- конкатенация (объединение или сложение) $\cup{},+$
- итерация $\cdot{}$
- пустая цепочка

Приоритет:
скобки > пустая строка > конкатенация > итерация

Языком $L$ над алфавитом $V$ называется подмножество цепочек конечной длины из множества всех цепочек $\alpha$ над алфавитом $V$.

**Операции над языками:**
1. Объединение $L\cup{M}$ - множество слов, принадлежащих хотя бы одному из языков
2. Конкатенация $L\cdot{M}$ - множество слов, полученных следующим образом: берётся слово из $L$ и справа к нему присоединяется слово из $M$
3. Итерация $L*$ - ноль или более конкатенаций $L$
4. Позитивное замыкание $L^{+}$ - одна или более конкатенаций $L$. 

Пример:
$L=\{A..Z,a..z\},D=\{0,1..9\}$
$L\cup{D}=\{A..Z,a..z,0..9\}$ - множество букв и цифр
$L\cdot{D}=\{a0,b1..\}$
$L^{*}=\{\emptyset{}abcd..z\}$ - множество всех строк из букв, включая пустую
$L^{4}=\{abcd,ftre,jklo..\}$ - множество всех строк из букв, длиной в 4 символа
$L(L\cup{D})=\{aa,a1..\}$ - множество строк, где первый символ - буква, второй - буква или цифра
$L(L\cup{D})^{*}=\{aa,a1,f1d,e2131f\}$ - множество строк, где первый символ - буква, а любое количество следующих - буква или цифра (например переменные)

**Способы задание языка:**
- перечислить все допустимые цепочки
- указания способов порождения цепочек языка (задать грамматику)
- определение методов распознавания цепочек языка (автоматы)

### Регулярные множества и выражения

Пусть K1 и K2 - множества цепочек
$K1 \cup{} K2$
$K1 \cap{} K2$
$K1*, K2*$

Класс регулярных множеств над конечным словарем $V$ определяется следующим образом:
1. $\varnothing{}\rightarrow{\{E\}}$
2. $a\in {V}\rightarrow{\{a\}}$, то этот символ есть регулярное множество
3. $S,T$ - регулярные множества, $\rightarrow{S\cup{T},S\cdot{T},S*,T*}$

Регулярные множества можно описать регулярными выражениями (формулами).

Класс регулярных выражений над конечным словарем $V$ определяется следующим образом:
1. $\emptyset{}\rightarrow{\{E\}}$ 
2. $a\in{V}\rightarrow{\{a\}}$ 
3. $S,T$ - регулярные выражение, $\rightarrow{S+{T},S\cdot{T},S*,T*}$ - регулярные выражения

Регулярные выражения - это форма или шаблон, схематично показывающая, как было построено, соответствующее ей регулярное множество с помощью операции 1-3.

Пример 1:
Задан алфавит $V=\{a,b\}$
1) $b\cdot{}a*$ - регулярное выражение
Регулярное выражение определяет множество цепочек, начинающихся с $b$ и заканчивающихся произвольным количеством $a$
$\{b,ba,baa..\}$
2) $a^{*}ba^{*}ba^{*}$
Регулярное выражение определяет множество цепочек, начинающихся с произвольного количества $a$ и содержащих ровно два вхождения $b$
3) $(a+bb)^{*}$
$\{NULL, a, bb, abb, aabb, aaabb, aaabbbb, bba\}$
Регулярное выражение определяет множество цепочек, состоящих из произвольного количества $a$ и произвольного количества пар $b$
4) $(a+b)^{*}(aa+bb)(a+b)^{*}$
$\{aa,bb,abbb, abaab\}$
Регулярное выражение, содержащее хотя бы одну пару рядомстоящих $a$ или $b$
5) $a(a+b)^{*}b$
...начинающихся на $a$, заканчивающихся на $b$ и содержащих произвольное количество $a,b$

### Формальные языки и грамматики

Язык программирование определяется синтаксисом и семантикой.

Формальное определение синтаксиса языка программирования, называется ==грамматикой==.

Теория формальных грамматик - это математический аппарат для изучения синтаксиса зыков программирования.

Язык над алфавитом $L(V)$ - это множество цепочек.

Существует два способа определения класса языков:
1. порождающая процедура - задается с помощью конечного множества правил, называемых грамматикой и порождающих в точности те цепочки которые принадлежат языку
2. распознающая процедура - задается некоторым абстрактным распознающим устройством (автоматом)

При построение трансляторов используются оба способа: грамматика, как средство описания синтаксиса языка программирования, а автомат как модель алгоритма распознавания предложений языка, которой кладется в основу построения транслятора. При это методически и технологически сначала проектируется грамматика, а затем по ней, как по источнику, строится алгоритм распознавателя.

Формальной порождающей грамматикой называется грамматика вида:
$G=(I,N,P,S)$

$T$ - конечное, не пустое множество терминальных символов. Терминалы - это терминальный словарь грамматики. Представляют собой базовые символы из которых строятся строки. Записываются строчными латинскими буквами.

$N$ - это конечное, не пустое множество нетерминальных символов (нетерминальный словарь грамматики). Записываются заглавными латинскими буквами. Нетерминалы представляют собой переменные, которые обозначают множество строк. Которые помогают в определении языка порождаемого грамматикой.

$P$ - множество продукции или правил. Продукция определяет способ, которым терминалы и нетерминалы объединяются друг с другом для создания строк.

$\alpha\to\beta$
В слове $\alpha$ присутствует нетерминальный символ.
Продукция с одинаковой объектной частью разделяется слешом (/).

$S\in N$
Стартовый символ грамматики (аксиома).
Стартовый символ - первый из нетерминальной части в списке продукции.

Пример:
$E\to T|E+T|E-T$
$T\to F|T*F|T/F$
$F\to a|b|c|(E)$

$G=(I,N,P,S)$
$T={a,b,c,+,-,*,/,(,)}$
$N={E,T,F}$
$S=E$

$E\implies T \implies T*F \implies T*F\implies F*F \implies (E)*F \implies (F+T)*F \implies (F+T)*F \implies (a+T)*F \implies (a+F)*F \implies (a+b)*F \implies (a+b)*c$

$(a+b)*c$ - может быть получена с помощью таких правил

Цепочка $w'$ непосредственно выводимая из $w$ c грамматикой $G$, если в множестве продукции есть правило вывода из $\phi \to \psi$.

$w \implies w'$
$w* \implies w'$
$w \implies$
$w \implies w_{1} \implies w_{2} \implies ... \implies w'$

Строка терминальных символов, полученная из стартового символа грамматики, называется предложением языка. Строки терминальных символов, порождаемые из стартового символа грамматики, образуют язык порождаемый этой грамматикой.

Практическое применение грамматик связанно с проблемой распознавания. Проблема распознавания разрешима, если существует алгоритм, который за конечное число шагов дает ответ на вопрос, "принадлежит ли произвольная цепочка над основным словарем грамматики языку порождаемого этой грамматикой". Если такой алгоритм существует, то язык называется распознаваемым. 
Если число шагов этого алгоритма зависит от цепочки и возможна предварительная оценка длины алгоритма, такой язык называется легко распознаваемый. На практике рассматриваются такие частные классы порождающих грамматик, которые соответствуют распознаваемым языкам. 

Наиболее важные классы таких грамматик предложены в 1959 году Наомом Хомским. 

Классификация грамматик по типу правил по Хомскому.