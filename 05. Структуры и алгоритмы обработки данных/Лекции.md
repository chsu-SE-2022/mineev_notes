
## Абстрактные типы данных

![[Абстрактные типы данных.png]]

Процесс создания программы для решения прикладной задачи обычно состоит из 3 этапов:
1. Задача описывается с помощью некоторого математического аппарата, тем самым создаётся математическая модель. На базе этой модели создаётся неформальный алгоритм;
2. На основе математической модели определяются абстрактные типы данных, которые буду использоваться в алгоритме. АТД - это математическая модель с совокупностью операторов определённых в рамках этой модели. После определения АТД создаётся программа на некотором псевдо-языке;
3. АТД преобразуется в конкретные структуры данных и операторы некоторого языка программирования на котором и создаётся итоговая программа.

==Пример:==

Раскраска географической карты.

Дана плоская географическая карта, требуется раскрасить государства на карте, так чтобы никакие два соседних не были раскрашены одним цветом. По возможности использовать небольшое количеств цифр.

1. Математическая модель - граф  
    Неформальный алгоритм - жадный
2. АТД - граф, с определенными на них операциями : нахождение вершин, смежных с вершиной i, определение цвета вершины раскраска вершины цветом color и тд.

```cpp
цикл i=1 to количество вершин{
	обнулить флаги цветов;
		цикл j=1 to количество вершин{
			если (вершина j смежная c i и вершина j выкрашена цветом color k);
				установить флаг цвета color k;
	найти первый свободный цвет color s;
	расскрасить вершину i цветом color s;

}
```

3. Структуры - двумерный и одномерный массивы.

## Структуры данных

**Линейные списки:** 
==Стек - Stack==
Это АТД работающий по принципу LIFO: Last In - First Out  
  
**Операции:**  
- nullStack - обнуление стека  
- empty - проверка стека на пустоту  
- push - добавление элементов в стек  
- pop -удаление элементов из стека

### Реализация стека

```cpp
struct Stack1 {
	int top;
	int* data;
};

void initStack(Stack1 &st, int capacity) {
	st.data = new int[capacity];
	st.top = -1; // Хранит индекс верхнего элемента стэка
}

void push(Stack1 &st, int value) {
	st.data[++st.top] = value;
}

int pop(Stack1 &st) {
	return st.data[st.top--];
}

void nullStack(Stack1 &st) {
	st.top = -1;
}

bool empty(Stack1 &st) {
	return st.top == -1;
}

void main() {
	Stack1 st;
	initStack(st, 10);
	push(st, 5); push(st, 3); push(st, 777); push(st, 111);
	while (!empty(st)) {
		int x;
		x = pop(st);
		cout << x << " ";
	}
	cout << endl;
	system("pause");
}
```

### Реализация стека динамическим списком

Недостаток реализации в массиве является то, что у массива заранее определяется размер и при достижении последнего элемента массива с попыткой добавления еще одного возникает ошибка переполнение стека. Чтобы этого избежать можно реализовывать стек с помощью динамического линейного списка.

```cpp
struct Node {
	int data;
	Node *next;
};

void initStack(Node *&top) {
	top = NULL;
}

void push(Node *&top, int value) {
	Node *tmp = new Node;
	tmp->next = top;
	top = tmp;
	top->data = value;
}

int pop(Node *&top) {
	Node *tmp = top;
	int d = top->data;
	top = top->next;
	delete(tmp);
	return d;
}

bool empty(Node *&top) {
	return top == NULL;
}

void nullStack(Node *&top) {
	Node *tmp;
	while (!empty(top)) {
		tmp = top;
		top = top->next;
		delete(tmp);
	}
}

void main() {
	Node *st;
	initStack(st);
	push(st, 5); push(st, 3); push(st, 777); push(st, 111);
	while (!empty(st)) {
		int x;
		x = pop(st);
		cout << x << " ";
	}
	cout << endl;
	system("pause");
}
```

==Очередь== - это линейный список, работающий по принципу первый вошёл, последним вышел (first in - fist out).

**Операции:**

- nullQueue - обнуление очереди;

- empty - проверка очереди на пустоту;

- add (enqueue) - добавление элемента в очередь;

- del (dequeue) - удаление элемента из очереди.

### Реализация очереди(динамический список)

```cpp
class Queue {

private:
	struct Node {
		int data;
		Node *next;
	}
	Node *head, *tail;

public:
	Queue() {
		head = NULL;
		tail = NULL;
	}

	bool empty() {
		return head == NULL;
	}

	void add(int value) {
		if (empty()) {
			head = new Node;
			head->data = value;
			head->next = NULL;
			tail = head;
		}
		else {
			tail->next = new Node;
			tail = tail->next;
			tail->data = value;
			tail->next = NULL;
		}
	}
	int del() {
		if (empty()) {
			cout << "Queue is empty" << endl;
			return 0;
		}

		else {
			int d = head->data;
			Node *tmp = head;
			head = head->next;
			delete(tmp);
			return d;
		}
	}

	void nullQueue() {
		Node *tmp;
		while (!empty()) {
			tmp = head;
			head = head->next;
			delete(tmp);
		}
	}
};
void main() {
	Queue q;
	q.add(5); q.add(3); q.add(777); q.add(111);
	while (!q.empty()) {
		int x;
		x = q.del();
		cout << x << " ";
	}
	cout << endl;
	system("pause");
}
```

Недостаток реализации в массиве заключается в том, что когда хвост очереди дойдет до последнего элемента массива, логично предположить, что очередь переполнена. Однако к этому времени из головы могут быть забраны несколько элементов и реально в массиве свободное место будет.

Чтобы в такой ситуации не перегонять всю очередь в начало массива было предложено считать массив закольцованным -когда за последним элементом массива следует первый. В этом случаи для вычисления номера элемента массива следующего за 
`i`-ым элементом используется формула:  
$$(i+1) \; \% \; size$$

Чтобы при такой реализации различать пустую и переполненную очереди, решили считать очередь пустой, если сразу за хвостом следует голова, а переполненной - если голова находится через один элемента от хвоста. То есть в массиве из `n` элементов максимально может поместится `n-1` элементов.

### Реализация очереди (массив)

```cpp
struct Queue1 { 
	int head,tail,size; 
	int *data; 
};
void nullQueue(Queue1 &g) {
	q.head=0;
	q.tail=q.size-1; 
}
void initQueue(Queue1 &q, int capacity) {
	q.size = capacity + 1;
	q.data = new int[q.size];
	nullQueue(q);
}

int next(Queue1 &q, int n) {
	return (n + 1) % q.size;
}

bool empty(Queue1 &q) {
	return next(q, q.tail) == q.head;
}

void add(Queue1 &q, int value) {
	if (next(q, next(q, q.tail)) == q.head) {
		cout << "Queue overflow" << endl;
	}
	else
	{
		q.tail = next(q, q.tail);
		q.data[q.tail] = value;
	}
}

int del(Queue1v &q) {
	if (empty(q)) {
		cout << "Queue is empty" << endl;
		return 0;
	}
	else
	{
		int d = q.data[q.head];
		q.head = next(q, q.head);
		return d;
	}

}
void main() {
	Queue1 q;
	initQueue(q, 3);
	add(q,5);add(q,3);add(q,777);
	while (!empty(q)) {
		int x;
		x = del(q);
		cout << x << " ";
	}
	cout << endl;
	system("pause");
}
```

==Дек - deq==
double ended queue

**Операции:**
- включение элемента справа
- включение элемента справа
- исключение элемента слева
- исключение элемента справа
- проверка на пустоту
- очистка

### Двусвязные динамические списки

![[Двусвязные динамические списки.png]]

- Перемещение по списку в двух направлениях
- Вставка элемента слева, справа, в середину
- Удаление элемента слева, справа, из середины

## Деревья

==Дерево== - это совокупность элементов называемых узлами, один из которых определяется как корень и родительских отношений, определяющих иерархическую структуру дерева.

**Рекурсивное дерево:**
1. Один узел является деревом. Этот же узел является его корнями.
2. Пусть узел $n$ узел и $T_{1},T_{2}, ... ,T_{k}$ деревья с корнями $n_{1},n_{2}, ... ,n_{k}$ соответственно. 
3. 
   Можно построить новое дерево сделав $n$ родителей узлов $T_{1},T_{2}, ... ,T_{n}$. В этом дереве $n-корень$, $T_{1},T_{2}, ... ,T_{k}$ - поддеревья узла $n$ (корня), а узлы $n_{1},n_{2}, ... ,n_{k}$ - прямые потомки (сыновья) узла $n$.

**Определения:**
1. Путем из узла $n_{1}$ в узел $n_{k}$ называется последовательность вершин $n_1,n_2,n_{k-1},n_k$ где для всех $i$ больше или равных 1 меньше $k$ узел $n_{i}$ является родительским для узла $n_{i+1}$.
2. Длиной пути называется число на единицу меньшее количества узлов составляющих этот путь.
3. Если существует путь из узла $a$ в узел $b$, то $a$ предок узла $b$, а $b$ потомок узла $a$.

Считается что любой узел является предком и потомком самому себе.
Таким образом корень дерева это узел не имеющий ни каких предков кроме самого себя.
4. Узел не имеющий потомков кроме самого себя, называется листом или терминальной вершиной дерева.
5. Высотой вершины называется длина самого длинного пути от этой вершины до одного из листов дерева (до самого длинного).
   Высотой дерева, называется высота его корня.
6. Глубина узла - это длин пути от корня до этого узла.
7. Дерево в котором нет ни одного узла называется нулевым деревом.

![[Пример дерева.png]]

Корень дерева - $A$
Листья дерева - $E,F,J,K,H,I$
Высота дерева - 3

**Способы обхода дерева:**
- Обход дерева фактически является упорядочением его вершин по некоторым правилам.

Наиболее часто встречается 3 вида обхода деревьев:
- прямой
- обратный
- симметричный

**Правила обхода:**
- Если дерево $T$ является нулевым деревом, то в список обхода заносится нулевая запись.
- Если дерево состоит из одного узла, то в список обхода заносится этот узел.
- Пусть $T$ - дерево с корнем $n$ и поддеревьями $T_{1},T_{2}, ... ,T_{k}$. 

![[Правила обхода.png]]

![[Пример дерева.png]]

$A B E F C G J K D H I$

Тогда для различных способов обхода:
1. При прямом обходе сначала посещается корень $n$, затем поддеревья  $T_{1},T_{2}, ... ,T_{k}$, также в прямом порядке.

![[Пример дерева.png]]

$A B E F C G J K D H I$

2. При обратном обходе сначала в обратном порядке обходится под дерево $T_{1}$ затем $T_{2}, ... ,T_{k}$, последним обходится $n$.

![[Пример дерева.png]]
$E F B J K G C H I D A$

3. При симметричном обходе сначала в симметричном порядке обходится поддерево $T_{1}$, затем корень $n$, далее поддеревья $T_{2}, ... ,T_{k}$

![[Пример дерева.png]]
$E B F A C J G K H D I$

### Бинарные деревья

Отдельный интерес в теории алгоритмов вызывают деревья у каждого узла которых не более двух потомков. Такие деревья называются бинарными или двоичными.

Бинарное дерево называется сбалансированным если разность высот левого и правого поддеревьев у любого узла дерева равна $|\pm x|$.

Если эта разность для любого узла равна 0, то дерево идеально сбалансировано.

### Способы представления бинарных деревьев:

1. С помощью одномерного массива

![[Способы представления бинарных деревьев (с помощью одномерного массива).png]]

$A B C D E F$

![[Способы представления бинарных деревьев.png]]

2. Представление с помощью динамической структуры

```cpp
struct Node{
	int data;
	Node *left,*right;
};

void add(int x,Node *&node){
	if (node==NULL){
		node=new Node;
		node->data=x;
		node->left=NULL;
		node->right=NULL;
	}
}

//Прямой обход (если вывод в конце - обратный, в середине - семмитричный)
void printTree(Node *node){
	if (node != NULL){
	cout << node->data << " ";
	ptintTree(node->left);
	printTree(node->right);
	}
}

int main(){
	Node *root=NULL;
	add(33,root);
	add(2,root->left);
	add(46,root->right);
	add(13,root->left->left);
	add(27,root->left->right);
	add(666,root->left->left->right);
	ptintTree(root);
	cout << endl; 
	system("pause");
	return 0;
}
```

![[Способы представления бинарных деревьев (с помощью динамической структуры).png]]

### Дерево Хаффмана

Будем строить бинарное дерево Хаффмана с использованием динамических структур данных. Узел будет содержать частоту (вероятность) вхождения символа, сам символ, а также указатели на левое поддерево, на правое поддерево и родительский узел.

По мимо структуры объявим два одномерных массива размером 256 элементов. В массиве `trees` будем хранить указатели на узлы с отдельными символами. По мере построения дерева будем объединять эти символы в деревья. Указатели на корни также хранить в этом массиве и так до тех пор пока не останется одного дерева. В массиве `symbols` - указатели на каждый символ, чтобы используя их, двигаясь к родительским узлам, быстро найти код символа. В переменной `size` - реальное число символов


```cpp
class HaffmanTree{
private:
struct Node{
	double p;
	char c;
	Node *left,*right,*parent;
};

Node *trees[256], symbols[256];
int size;

public:
	HuffmanTree(int col){size=col;}
	
	void makeTree(int col){
		if (col>1){
			double minp1=1;
			int n1=0;
			for (int i=0;i<size;i++)//ищем первый минимум
				if (trees[i] != NULL && trees[i]->p<minp1){
				}
		double minip2=1;
		int n2=0;
		for (int i=0;i<size;i++)//ищем второй минимум
			if (trees[i] != NULL && trees[i]->p<minp2 && i != n1){
				minp2=trees[i]->p;
				n2=i;
			}
		Node *tmp = new Node;//новое дерево
		tmp->left=trees[n1];tmp->right=trees[n2];
		trees[n1]->parent=tmp;trees[n2]->parent=tmp;
		tmp->p=trees[n1]->p+trees[n2]->p;
		tmp->parent=NULL;
		tress[n1]=tmp;
		trees[n2]=NULL;
		makeTree(col-1);//опять в лес по дрова...
	}
}
		void readInfo(){
			for (int i=0;i<size;i++){
				trees[i]=new Node;
				symbols[i]=trees[i];
				cout << "Eter symbol: ";cin >> trees[i]->c;
				cout << "p=";cin >> trees[i]->p;
				trees[i]->left=NULL;
				trees[i]->right=NULL;
				trees[i]->parent=NULL;
			}
		}
	void showCodes(){
		if (size==1) 
			cout << symbols[0]->c << " - " << endl;
		else {
			Node *tmp;
			string code;
			for (int i=0;i<size;i++){
				tmp=symbols[i];
				code="";
				while (tmp->parent != NULL){
					if (tmp->parent->left==tmp)
						code="0"+code;
					else
						code="1"+code;
					tmp=tmp->parent;}
					
			cout << symbols[i]->c << " - " << endl;
			}
			}
		
		}	
	};

int main(){
	int col=5;
	HaffmanTree ht(col);
	ht.readInfo();
	ht.makeTree(col);
	ht.showCodes();
	cout << endl;
	system("pause")
	return 0;
}
```


## Алгоритмы полного перебора

Многие задачи заключаются в нахождении одного или нескольких искомых из полного набора некоторых вариантов. Эти задачи называются задачами выбора на доборе дискретных данных. Самый простой способ решения задачи выбора - перебрать все варианты и выбрать среди них те которые требуются по условию.

Плюсом данного метода является гарантированное получение точного и полного результата. Главным минусом является большая временная сложность алгоритма при большом наборе исходном данных. 

### Перебор циклами

Программа представляет собой несколько вложенных циклов которые и перебирают все варианты. 

Пример: Найти количество счастливых автобусных билетов.


```cpp
int col=0;
for (int a=0;a<=9;a++)
	for (int b=;b<=9;b++)
		for (int c=0;c<=9;c++)
			for (int d=0;d<=9;d++)
				for (int e=0;e<=9;e++)
					for (int f=0;f<=9;f++)
		if (a+b+c==d+e+f) col++;
		cout << col << " " << col/10000.0 << endl;


```

Преимущество перебора циклами:
- простота реализации
Недостатки:
- часто заранее неизвестно какое количество циклов нужно вкладывать друг в друга

### P-ичный перебор

Имеется $N$ объектов каждому их которых поставлена некоторая стоимость. Требуется разделить объекты на две группы так, чтобы разность стоимостей между группами была минимальной.

Поскольку каждый объект может оказаться в одной из двух групп закрепим за каждым из объектов двоичное число (0 или 1). Если количество объектов $N$ для полного перебора необходимо просмотреть все комбинации $n-значных$ двоичных чисел от $n-нулей$ и $n-единиц$. Всего $2^i$.

Для реализации помимо массива объектов можно завести массив нулей и единиц. Считая его двоичным числом, на каждом шаге при выборе нового варианта прибавляя к этому числу 1.

```cpp
void plus(int *m,int n){
	int i=n;
	while (m[i]==1)
		mm[i--]=0;
	m[i]=1;
	}

int main(){
	const int n=5;
	int min=15;
	int m[n+1]={0,1,2,3,4,5},
		bin[n+1]={0,0,0,0,0,0};
	while (bin[0]==0){
		int s1=0,s2=0;
		for (int i=1;i,+n;i++)
			if (bin[i]==0) {s1+=m[i];}
			else {s2+=m[i];}
			if (abs(s1-s2)<min)
				min=abs(s1-s2);
			plus(bin,n)
	}
}
```

Данная задача решена методом полного двоичного перебора. В общем случаи перебор может быть P-ичным.
Например: Цифры 1,2,3,4,5,6,7,8,9 записаны одна за другой. Расставить между ними знаки $+, -, *, :$ или ничего , так чтобы получилось заданное число $N$. Задачу можно решит полным пятеричным перебором.

### Полный рекурсивный перебор

Дан квадратный числовой массив. Найти путь из левого верхнего угла массива в правый нижний, чтобы сумма чисел по данному пути была максимальной. Из каждого элемента массива допустимо двигается только вправо или вниз.

![[Полный рекурсивный перебор (Пример).png]]


```cpp
int Max=0;
void poisk(int *m,int n,int i,int j,int s){
	s+=m[i][j];
	if (i==n-1 && j==n-1 && s>Max) Max=s;
	if (i<n-1) poisk(m,n,i+1,j,s);
		if (j<n-1) poisk(m,n,i,j+1,s);
}

int main(){
	const int n=5;
	int m[n][n]={{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1},
				{1,1,1,1,1}};
	int **a=new int*[n];
	for (int i=0;i<n;i++){
		a[i]=new int [n];
		for (int j=0;j<n,j++)
			a[i][j]=1;
		}
		poisk(a,n,0,0,0);
}
```

Основной плюс функций рекурсивного перебора в их простоте и компактности. Минус возможное переполнение стека и медленная работа.

## Метод динамического программирования

В предыдущей задаче на больших $N$ полный перебор невозможен. 

Данную задачу модно решить более быстрым алгоритмом, реализующим метод динамического программирования. Суть метода заключается в том, что в начале решается задача минимальной размерности. Далее на основании этого решения задача следующей размерности, и так далее пока не будет решена задача требуемой размерности. При решении задачи размерности $k$ на основании уже решеной $k-1$ размерности решение принимается на основании так называемого принципа оптимальности.

**Пример 1:**
Предыдущую задачу можно решить методом динамического программирования (как это делалось на ЕГЭ).

$A:$

|  5  |  7  |  1  |  8  |  2  |
|:---:|:---:|:---:|:---:|:---:|
|  3  |  9  |  2  |  5  |  6  |
|  7  |  6  |  1  |  2  |  7  |
|  5  |  4  |  3  |  2  |  8  |
|  9  |  9  |  6  |  1  |  2  |

$B:$

|  5  | 12  | 13  | 21  | 23  |
|:---:|:---:|:---:|:---:|:---:|
|  8  | 21  | 23  | 28  | 34  |
| 15  | 27  | 28  | 30  | 41  |
| 20  | 31  | 34  | 36  | 49  |
| 29  | 40  | 46  | 47  | 51  | 

Заполняя на основании исходного массива $A$ итоговый массив $B$, мы в ячейке `B[n-1][n-1]` получим исходное максимальное значение.

Для все элементов массива $B$, кроме тех которые стоят в первом столбце и первой строке, значение вычисляется по формуле: 
`B[i][j] = Max(A[i][j]+B[i-1][j];A[i][j]+B[i][i-1]`
Это и есть принцип оптимальности. (для данной задачи)

Если требуется найти не только максимальное значение суммы, но и путь по которому эта сумма была получена, это можно сделать двигаясь от элемента массива с индексами `B[n-1][n-1]` к элементу `B[0][0]` по "жадному" алгоритму.

|  1  |  1  |  1  |  1  |  1  |
|:---:|:---:|:---:|:---:|:---:|
|  1  |  2  |  3  |  4  |  5  |
|  1  |  3  |  6  | 10  | 15  |
|  1  |  4  | 10  | 20  | 35  |
|  1  |  5  | 15  | 35  | 70  |

Получается треугольник Паскаля.

**Пример 2:**
Кое кто хочет подписать бумагу у министра, министр подписывает документ, если на нем стоит подпись любого работника с последнего этажа министерства. Каждый работник сидит в отдельном кабинете. Количество кабинетов $1\le M \le 500$, этажей $1 \le N \le100$ 
Каждый работник сидит в отдельном кабинете, подписывает документ, если на нем стоит подпись любого работника из кабинета ниже или из одного из соседних. За свою подпись каждый работник берет некоторую сумму. Известность этой суммы в каждом кабинете министерства. Требуется найти путь от первого этажа министерства к последнему, чтобы конечная сумма была минимальной.

Заведем 3 двумерных массива. В первом хранятся исходные данные суммы в каждом кабинете, во втором будем просчитывать наилучшую сумму для каждого кабинета, в третьем будем отмечать путь (откуда пришли).

![[Метод динамического программирования. Пример 2.png]]

После заполнения массивов $B$ и $C$ в последней заполненной строке находим минимум, это и будет итоговое значение суммы.
Путь по министерству найдем, пользуясь массивом $C$. 

`input.txt`
5 7 
10 10 10 10 10 1 10
10 10 10 10 1 1 10
10 10 1 1 1 10 10
10 10 1 10 10 10 10
10 10 1 10 10 10 10


```cpp
void main() {
	int m,n;
	ifstream f("input.txt");
	f >> n >> m;
	int *currentFloor = new int[m];
	int *bestFloor = new int[m];
	int **direction = new int *[n];
	for (int i=0;i<n;i++) {
		direction[i] = new int[m];
		for (int j=0;j<m;j++) {
			direction[i][j]=0;
			bestFloor[j]=0;
		}
	}
	for (int i=0;i<n;i++) {
		fot (int j=0;j<n;j++) {
			f >> currentFloor[j];
			bestFloor[j]+=currentFloor[j] // идем снизу
		}
		for (int j=1;j<m;j++) {
			if (bestFloor[j-1]+currentFloor[j]<bestFloor[j]) {
				 bestFloor[j]=bestFloor[j-1]+currentFloor[j];
				 direction[i][j]=-1;
			}
		}
		for (int j=m-2;j>=0;j--) {
			if (bestFloor[j+1]+currentFloor[j]<bestFloor[j]) {
				 bestFloor[j]=bestFloor[j+1]+currentFloor[j];
				 direction[i][j]=1;
			}
		}
	}
	int min=100000000, nmin=-1;
	for (int j=0;j<m;j++) {
		if (min>bestFloor[j]){min=bestFloor[j]; nmin=j;}
	}
	
	cout << nmin << " - " << min << endl;
	
	for (int i=0;i<n;i++) {
		for (int j=0;j<m;j++) {
			cout << direction[i][j];
		}
	cout <<endl;
	}
	
	f.close();
		
		
}

```


Задача о рюкзаке
Имеется $N$ видов предмета, масса одного предмета $i-го$ вида $m_{i}$, стоимость одного предмета $i-го$ вида $s_{i}$, количество предметов каждого вида неограниченно. Имеется рюкзак, который может выдержать массу $Mr$. Сколько предметов каждого вида нужно поместить в рюкзак, чтобы рюкзак не порвался и стоимость предметов в рюкзаке была максимальна. Для решения будем просчитывать все рюкзаки с $Mr$ равного 0 и заканчивая последним значением. Сначала каждый из рюкзаков будем помещать предметы первого вида просчитывая стоимость рюкзака. Затем также в каждый из них будем пытаться поместить 0,1,2, ... предметов второго вида, заполняя остаток предметами первого, а этот остаток уже посчитан.

1. type - m=2;s=5
2. type - m=1;s=7
3. type - m=3;s=10

| Mr  |   1 type    |      2 type      | 3 type |
|:---:|:-----------:|:----------------:|:------:|
|  0  | 1 - 0; s=0  | 1 -0,2 - 0,s = 0 |        |
|  1  | 1 - 0; s=0  | 1 -0,2 - 1,s = 2 |        |
|  2  | 1 - 1; s=5  | 1 -0,2 - 1,s = 5 |        |
|  3  | 1 - 1; s=5  | 1 -1,2 - 0,s = 7 |        |
|  4  | 1 - 2; s=10 | 1 -1,2 - 1,s = 0 |        |
|  5  | 1 - 2; s=10 | 1 -1,2 - 2,s = 0 |        |
